function escapeHtml(text) {
if (text === null || text === undefined) return '';
const div = document.createElement('div');
div.textContent = String(text);
return div.innerHTML;
}
function sanitizeUrl(url) {
if (!url) return '#';
const trimmed = String(url).trim();
if (trimmed.startsWith('/') ||
trimmed.startsWith('./') ||
trimmed.startsWith('../') ||
trimmed.startsWith('http://') ||
trimmed.startsWith('https://')) {
return trimmed;
}
if (/^[a-zA-Z0-9_\-./]+$/.test(trimmed) && !trimmed.includes(':')) {
return trimmed;
}
return '#';
}
function escapeAttr(value) {
if (value === null || value === undefined) return '';
return String(value)
.replace(/&/g, '&amp;')
.replace(/"/g, '&quot;')
.replace(/'/g, '&#x27;')
.replace(/</g, '&lt;')
.replace(/>/g, '&gt;');
}
let recipes = [];
let fullRecipesCache = {};
let categories = new Set();
let allTags = new Set();
let currentFilter = { search: '', category: '', tag: '', collections: ['grandma-baker', 'mommom', 'granny', 'all'], ingredients: [], ingredientMatchInfo: null };
let showMetric = false;
let recipeScale = 1;
let currentRecipeId = null;
let ingredientIndex = null;
let selectedIngredients = [];
let ingredientSearchOptions = {
matchMode: 'any',
missingThreshold: 0
};
let autocompleteHighlightIndex = -1;
let userStaples = [];
let includeStaples = true;
let justStaplesMode = false;
let substitutionsData = null;
let enableSubstitutions = true;
let activeSubstitutions = {};
let currentRecipeNutrition = null;
let kitchenTipsData = null;
let pagefind = null;
let pagefindLoading = null;
let pagefindSearchResults = null;
let nutritionFilter = {
timeLimit: null,
calories: { min: null, max: null },
carbs: { min: null, max: null },
protein: { min: null, max: null },
fat: { min: null, max: null },
onlyWithNutrition: false,
activeDietPreset: null
};
const REMOTE_COLLECTIONS = {
'mommom-baker': {
displayName: 'MomMom Baker',
baseUrl: 'https://jsschrstrcks1.github.io/MomsRecipes/',
recipesUrl: 'https://jsschrstrcks1.github.io/MomsRecipes/data/recipes.json',
indexUrl: 'https://jsschrstrcks1.github.io/MomsRecipes/data/recipes-index.json',
sharded: true
},
'granny-hudson': {
displayName: 'Granny Hudson',
baseUrl: 'https://jsschrstrcks1.github.io/Grannysrecipes/',
recipesUrl: 'https://jsschrstrcks1.github.io/Grannysrecipes/granny/recipes_master.json',
indexUrl: 'https://jsschrstrcks1.github.io/Grannysrecipes/granny/recipes-index.json',
dataPath: 'granny/',
sharded: true
},
'all': {
displayName: 'Other Recipes',
baseUrl: 'https://jsschrstrcks1.github.io/Allrecipes/',
recipesUrl: 'https://jsschrstrcks1.github.io/Allrecipes/data/recipes.json',
indexUrl: 'https://jsschrstrcks1.github.io/Allrecipes/data/recipes-index.json',
sharded: true
}
};
let remoteShardCache = {};
let remoteIndexCache = {};
let loadingShards = {};
const DIET_PRESETS = {
'low-carb': {
name: 'Low Carb',
carbs: { max: 20 },
description: 'Max 20g carbs per serving'
},
'low-cal': {
name: 'Low Cal',
calories: { max: 400 },
description: 'Max 400 calories per serving'
},
'high-protein': {
name: 'High Protein',
protein: { min: 25 },
description: 'Min 25g protein per serving'
},
'low-fat': {
name: 'Low Fat',
fat: { max: 10 },
description: 'Max 10g fat per serving'
},
'low-sodium': {
name: 'Low Sodium',
sodium: { max: 500 },
description: 'Max 500mg sodium per serving'
}
};
let ingredientResultsPageSize = 10;
let ingredientResultsShown = 0;
let currentIngredientMatches = [];
const STAPLES_PRESETS = {
basics: [
'salt', 'pepper', 'sugar', 'flour', 'butter', 'oil', 'eggs', 'milk',
'garlic', 'onion', 'water'
],
baking: [
'baking powder', 'baking soda', 'vanilla extract', 'brown sugar',
'powdered sugar', 'vegetable oil', 'shortening', 'cocoa powder'
],
asian: [
'soy sauce', 'sesame oil', 'rice vinegar', 'ginger', 'green onions',
'garlic', 'rice', 'cornstarch'
],
mexican: [
'cumin', 'chili powder', 'cilantro', 'lime', 'jalape√±o', 'tortillas',
'black beans', 'salsa', 'cheese'
],
italian: [
'olive oil', 'garlic', 'basil', 'oregano', 'parmesan cheese',
'tomato sauce', 'pasta', 'red pepper flakes'
]
};
const MEAL_PAIRINGS = {
mains: ['sides', 'salads', 'breads', 'beverages'],
sides: ['mains', 'salads'],
salads: ['mains', 'breads', 'soups'],
soups: ['breads', 'salads', 'mains'],
appetizers: ['mains', 'beverages'],
breakfast: ['beverages', 'breads'],
breads: ['soups', 'mains', 'salads'],
desserts: ['beverages'],
beverages: ['mains', 'desserts', 'breakfast']
};
let shoppingList = [];
let selectedMealRecipes = [];
document.addEventListener('DOMContentLoaded', init);
async function init() {
await Promise.all([
loadRecipes(),
loadIngredientIndex()
]);
setupEventListeners();
setupIngredientSearch();
setupStaplesSystem();
setupNutritionFilters();
handleRouting();
}
async function loadRecipes() {
try {
const response = await fetch('data/recipes_index.json');
const data = await response.json();
recipes = data.recipes || [];
recipes.forEach(recipe => {
if (recipe.category) categories.add(recipe.category);
if (recipe.tags) recipe.tags.forEach(tag => allTags.add(tag));
});
console.log(`Loaded ${recipes.length} recipes (index)`);
updateCollectionCounts();
} catch (error) {
console.error('Failed to load recipes:', error);
showError('Unable to load recipes. Please refresh the page.');
}
}
let localShardCache = {};
let loadingLocalShards = {};
const CATEGORY_SHARDED_COLLECTIONS = ['mommom-baker', 'all'];
async function loadFullRecipe(recipeId) {
if (fullRecipesCache[recipeId]) {
return fullRecipesCache[recipeId];
}
const indexEntry = recipes.find(r => r.id === recipeId);
if (!indexEntry) {
console.warn(`Recipe ${recipeId} not found in index`);
return null;
}
const collection = indexEntry.collection;
const category = indexEntry.category;
const usesCategoryShards = CATEGORY_SHARDED_COLLECTIONS.includes(collection);
let shardKey, shardUrl;
if (usesCategoryShards && category) {
shardKey = `${collection}:${category}`;
shardUrl = `data/recipes-${collection}-${category}.json`;
} else {
shardKey = collection;
shardUrl = `data/recipes-${collection}.json`;
}
if (!localShardCache[shardKey]) {
if (!loadingLocalShards[shardKey]) {
loadingLocalShards[shardKey] = (async () => {
try {
console.log(`Loading local shard: ${shardUrl}`);
const response = await fetch(shardUrl);
if (!response.ok) {
console.warn(`Failed to load shard ${shardKey}: ${response.status}`);
return false;
}
const data = await response.json();
const shardRecipes = data.recipes || [];
localShardCache[shardKey] = shardRecipes;
shardRecipes.forEach(r => {
fullRecipesCache[r.id] = r;
});
console.log(`Loaded ${shardRecipes.length} recipes from ${shardKey} shard`);
return true;
} catch (error) {
console.error(`Error loading shard ${shardKey}:`, error);
return false;
}
})();
}
await loadingLocalShards[shardKey];
}
if (fullRecipesCache[recipeId]) {
return fullRecipesCache[recipeId];
}
console.warn(`Recipe ${recipeId} not found in ${shardKey} shard`);
return null;
}
async function loadRemoteRecipe(recipeId, indexEntry, collectionConfig) {
const collection = indexEntry.collection;
const category = indexEntry.category;
const dataPath = collectionConfig.dataPath || 'data';
if (collectionConfig.sharded && category) {
const shardKey = `${collection}:${category}`;
if (remoteShardCache[shardKey]) {
const recipe = remoteShardCache[shardKey].find(r => r.id === recipeId);
if (recipe) return recipe;
}
try {
const shardUrl = `${collectionConfig.baseUrl}${dataPath}/recipes-${category}.json`;
console.log(`Loading remote shard: ${shardUrl}`);
const response = await fetch(shardUrl);
if (!response.ok) {
console.warn(`Failed to load shard ${category}: ${response.status}`);
} else {
const data = await response.json();
const shardRecipes = data.recipes || [];
remoteShardCache[shardKey] = shardRecipes;
shardRecipes.forEach(r => {
fullRecipesCache[r.id] = r;
});
console.log(`Loaded remote shard ${category} (${shardRecipes.length} recipes)`);
const recipe = shardRecipes.find(r => r.id === recipeId);
if (recipe) return recipe;
}
} catch (error) {
console.warn(`Error loading shard ${category}:`, error);
}
}
if (collectionConfig.recipesUrl) {
try {
console.log(`Loading remote recipes (monolithic): ${collectionConfig.recipesUrl}`);
const response = await fetch(collectionConfig.recipesUrl);
if (!response.ok) {
console.error(`Failed to load remote recipes: ${response.status}`);
return null;
}
const data = await response.json();
const remoteRecipes = data.recipes || data || [];
remoteRecipes.forEach(r => {
fullRecipesCache[r.id] = r;
});
console.log(`Loaded remote collection (${remoteRecipes.length} recipes)`);
return remoteRecipes.find(r => r.id === recipeId);
} catch (error) {
console.error('Error loading remote recipes:', error);
return null;
}
}
return null;
}
async function loadRemoteIndex(collection, collectionConfig) {
if (remoteIndexCache[collection]) {
return remoteIndexCache[collection];
}
if (!collectionConfig.sharded || !collectionConfig.indexUrl) {
return null;
}
try {
const response = await fetch(collectionConfig.indexUrl);
if (!response.ok) {
console.warn(`Failed to load remote index: ${response.status}`);
return null;
}
const indexData = await response.json();
remoteIndexCache[collection] = indexData;
console.log(`Loaded remote index for ${collection} (${indexData.shards?.length || 0} shards)`);
return indexData;
} catch (error) {
console.error(`Error loading remote index for ${collection}:`, error);
return null;
}
}
async function preloadRemoteCollection(collection) {
const collectionConfig = REMOTE_COLLECTIONS[collection];
if (!collectionConfig) {
console.warn(`Unknown collection: ${collection}`);
return 0;
}
if (!collectionConfig.sharded) {
try {
const response = await fetch(collectionConfig.recipesUrl);
const data = await response.json();
const recipes = data.recipes || data || [];
recipes.forEach(r => { fullRecipesCache[r.id] = r; });
console.log(`Preloaded ${recipes.length} recipes from ${collection} (monolithic)`);
return recipes.length;
} catch (error) {
console.error(`Failed to preload ${collection}:`, error);
return 0;
}
}
const indexData = await loadRemoteIndex(collection, collectionConfig);
if (!indexData || !indexData.shards) {
return 0;
}
const dataPath = collectionConfig.dataPath || 'data';
let totalLoaded = 0;
const shardPromises = indexData.shards.map(async (shard) => {
const category = shard.category;
const shardKey = `${collection}:${category}`;
if (remoteShardCache[shardKey]) {
return remoteShardCache[shardKey].length;
}
try {
const shardFile = shard.file || `recipes-${category}.json`;
const shardUrl = `${collectionConfig.baseUrl}${dataPath}/${shardFile}`;
const response = await fetch(shardUrl);
if (!response.ok) {
console.warn(`Failed to load shard ${shardFile}: ${response.status}`);
return 0;
}
const data = await response.json();
const shardRecipes = data.recipes || [];
remoteShardCache[shardKey] = shardRecipes;
shardRecipes.forEach(r => { fullRecipesCache[r.id] = r; });
return shardRecipes.length;
} catch (error) {
console.warn(`Error loading shard ${category}:`, error);
return 0;
}
});
const results = await Promise.all(shardPromises);
totalLoaded = results.reduce((sum, count) => sum + count, 0);
console.log(`Preloaded ${totalLoaded} recipes from ${collection} (${indexData.shards.length} shards)`);
return totalLoaded;
}
window.preloadRemoteCollection = preloadRemoteCollection;
let ingredientIndexLoading = null;
async function loadIngredientIndex() {
if (ingredientIndex) return ingredientIndex;
if (ingredientIndexLoading) return ingredientIndexLoading;
ingredientIndexLoading = (async () => {
try {
const response = await fetch('data/ingredient-index.json');
ingredientIndex = await response.json();
console.log(`Loaded ingredient index: ${ingredientIndex.meta.total_ingredients} ingredients from ${Object.keys(ingredientIndex.meta.collections || {}).length} collections`);
updateLastUpdatedBadge();
return ingredientIndex;
} catch (error) {
console.error('Failed to load ingredient index:', error);
ingredientIndexLoading = null;
return null;
}
})();
return ingredientIndexLoading;
}
function formatTimeAgo(isoString) {
try {
const date = new Date(isoString);
const now = new Date();
const diffMs = now - date;
const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
if (diffDays > 30) {
return date.toLocaleDateString();
} else if (diffDays > 0) {
return `${diffDays}d ago`;
} else if (diffHours > 0) {
return `${diffHours}h ago`;
} else {
return 'just now';
}
} catch (e) {
return 'unknown';
}
}
function updateLastUpdatedBadge() {
const badge = document.getElementById('index-last-updated');
if (!badge || !ingredientIndex || !ingredientIndex.meta.built_at) return;
try {
const builtAt = new Date(ingredientIndex.meta.built_at);
const timeAgo = formatTimeAgo(ingredientIndex.meta.built_at);
const collectionNames = {
'grandma-baker': 'Grandma',
'mommom-baker': 'MomMom',
'granny-hudson': 'Granny',
'all': 'Other'
};
const localCounts = {};
for (const recipe of recipes) {
const coll = recipe.collection || 'unknown';
localCounts[coll] = (localCounts[coll] || 0) + 1;
}
const collectionParts = [];
let totalRecipes = recipes.length;
for (const [id, count] of Object.entries(localCounts)) {
const name = collectionNames[id] || id;
collectionParts.push(`${name}: ${count}`);
}
badge.innerHTML = `
<span class="index-summary">Index updated ${timeAgo} (${totalRecipes} recipes)</span>
<span class="collection-breakdown">${collectionParts.join(' | ')}</span>
`;
badge.title = `Built: ${builtAt.toLocaleString()}\nRecipes loaded: ${totalRecipes}`;
} catch (e) {
console.error('Error updating last-updated badge:', e);
}
}
let substitutionsLoading = null;
async function loadSubstitutions() {
if (substitutionsData) return substitutionsData;
if (substitutionsLoading) return substitutionsLoading;
substitutionsLoading = (async () => {
try {
const response = await fetch('data/substitutions.json');
substitutionsData = await response.json();
console.log(`Loaded ${substitutionsData.substitutions.length} substitution rules`);
return substitutionsData;
} catch (error) {
console.error('Failed to load substitutions:', error);
substitutionsLoading = null;
return null;
}
})();
return substitutionsLoading;
}
let kitchenTipsLoading = null;
async function loadKitchenTips() {
if (kitchenTipsData) return kitchenTipsData;
if (kitchenTipsLoading) return kitchenTipsLoading;
kitchenTipsLoading = (async () => {
try {
const response = await fetch('data/kitchen-tips.json');
kitchenTipsData = await response.json();
const totalTips = kitchenTipsData.categories.reduce((sum, cat) => sum + cat.tips.length, 0);
console.log(`Loaded ${totalTips} kitchen tips in ${kitchenTipsData.categories.length} categories`);
return kitchenTipsData;
} catch (error) {
console.error('Failed to load kitchen tips:', error);
return null;
}
})();
return kitchenTipsLoading;
}
async function loadPagefind() {
if (pagefind) return pagefind;
if (pagefindLoading) return pagefindLoading;
pagefindLoading = (async () => {
try {
pagefind = await import('/_pagefind/pagefind.js');
await pagefind.init();
console.log('Pagefind search loaded');
return pagefind;
} catch (error) {
try {
pagefind = await import('./_pagefind/pagefind.js');
await pagefind.init();
console.log('Pagefind search loaded (relative path)');
return pagefind;
} catch (e) {
console.warn('Pagefind not available, using basic search:', e.message);
return null;
}
}
})();
return pagefindLoading;
}
async function searchWithPagefind(query) {
if (!query || query.length < 2) {
return null;
}
const pf = await loadPagefind();
if (!pf) {
return null;
}
try {
const search = await pf.search(query);
if (!search || !search.results) {
return { localIds: [], remoteResults: [] };
}
const localIds = [];
const remoteResults = [];
for (const result of search.results.slice(0, 100)) {
const data = await result.data();
if (data.url) {
if (data.url.startsWith('http')) {
remoteResults.push({
title: data.meta?.title || 'Unknown Recipe',
url: data.url,
collection: data.meta?.collection || 'External',
category: data.meta?.category || '',
description: data.meta?.description || ''
});
} else {
const id = data.url.split('#')[1];
if (id) localIds.push(id);
}
}
}
return { localIds, remoteResults };
} catch (error) {
console.error('Pagefind search error:', error);
return null;
}
}
function getKitchenTipsForRecipe(recipe) {
if (!kitchenTipsData || !recipe) return [];
const tips = [];
const recipeCategory = (recipe.category || '').toLowerCase();
const recipeTitle = (recipe.title || '').toLowerCase();
const recipeId = recipe.id || '';
const categoryMapping = {
'desserts': ['candy-making', 'baking-cakes', 'baking-cookies', 'baking-pies'],
'breads': ['baking-bread'],
'mains': ['meat-cooking', 'sauces', 'frying'],
'sides': ['vegetables', 'sauces'],
'breakfast': ['eggs', 'baking-bread'],
'soups': ['soups-stews'],
'appetizers': ['frying', 'sauces'],
'salads': ['vegetables'],
'beverages': []
};
const relevantCategories = categoryMapping[recipeCategory] || ['general'];
if (!relevantCategories.includes('general')) {
relevantCategories.push('general');
}
for (const cat of kitchenTipsData.categories) {
if (relevantCategories.includes(cat.id)) {
for (const tip of cat.tips) {
const relatedToRecipe = tip.relatedRecipes?.some(r =>
recipeId.includes(r) || recipeTitle.includes(r)
);
tips.push({
...tip,
category: cat.name,
categoryIcon: cat.icon,
isDirectlyRelated: relatedToRecipe
});
}
}
}
tips.sort((a, b) => {
if (a.isDirectlyRelated && !b.isDirectlyRelated) return -1;
if (!a.isDirectlyRelated && b.isDirectlyRelated) return 1;
return 0;
});
return tips.slice(0, 5);
}
function getAllKitchenTips() {
if (!kitchenTipsData) return [];
return kitchenTipsData.categories;
}
function renderKitchenTipsForRecipe(recipe) {
const tips = getKitchenTipsForRecipe(recipe);
if (tips.length === 0) return '';
const tipsHtml = tips.map(tip => `
<div class="kitchen-tip ${tip.isDirectlyRelated ? 'directly-related' : ''}">
<span class="tip-icon">${escapeHtml(tip.categoryIcon)}</span>
<div class="tip-content">
<p class="tip-text">"${escapeHtml(tip.text)}"</p>
<span class="tip-attribution">‚Äî ${escapeHtml(tip.attribution)}</span>
</div>
</div>
`).join('');
return `
<div class="kitchen-tips-section">
<h3 class="kitchen-tips-header">üëµ Family Kitchen Wisdom</h3>
<div class="kitchen-tips-list">
${tipsHtml}
</div>
</div>
`;
}
const FRACTION_MAP = {
'0.125': '‚Öõ',
'0.25': '¬º',
'0.333': '‚Öì',
'0.375': '‚Öú',
'0.5': '¬Ω',
'0.625': '‚Öù',
'0.667': '‚Öî',
'0.75': '¬æ',
'0.875': '‚Öû'
};
const MIN_PRACTICAL_MEASUREMENTS = {
'teaspoon': 0.125,
'tsp': 0.125,
'tablespoon': 0.25,
'tbsp': 0.25,
'cup': 0.125,
'cups': 0.125,
'egg': 0.5,
'eggs': 0.5,
'ounce': 0.25,
'oz': 0.25,
'pound': 0.125,
'lb': 0.125
};
function scaleQuantity(quantity, scale) {
if (!quantity || scale === 1) {
return { value: parseQuantity(quantity), display: String(quantity || ''), warning: null };
}
const numericValue = parseQuantity(quantity);
if (numericValue === null || isNaN(numericValue)) {
return { value: null, display: String(quantity || ''), warning: null };
}
const scaled = numericValue * scale;
const display = formatQuantity(scaled);
return { value: scaled, display, warning: null };
}
function parseQuantity(quantity) {
if (typeof quantity === 'number') return quantity;
if (!quantity) return null;
const str = String(quantity).trim();
const unicodeFractions = {
'‚Öõ': 0.125, '¬º': 0.25, '‚Öì': 0.333, '‚Öú': 0.375,
'¬Ω': 0.5, '‚Öù': 0.625, '‚Öî': 0.667, '¬æ': 0.75, '‚Öû': 0.875
};
let processed = str;
for (const [frac, val] of Object.entries(unicodeFractions)) {
processed = processed.replace(frac, ` ${val}`);
}
const mixedMatch = processed.match(/^(\d+)\s+(\d+)\/(\d+)$/);
if (mixedMatch) {
return parseInt(mixedMatch[1]) + parseInt(mixedMatch[2]) / parseInt(mixedMatch[3]);
}
const fractionMatch = processed.match(/^(\d+)\/(\d+)$/);
if (fractionMatch) {
return parseInt(fractionMatch[1]) / parseInt(fractionMatch[2]);
}
const numMatch = processed.match(/^[\d.]+/);
if (numMatch) {
const baseNum = parseFloat(numMatch[0]);
const remainder = processed.slice(numMatch[0].length).trim();
if (remainder) {
const remainderVal = parseFloat(remainder);
if (!isNaN(remainderVal)) {
return baseNum + remainderVal;
}
}
return baseNum;
}
return null;
}
function formatQuantity(value) {
if (value === null || isNaN(value)) return '';
if (Number.isInteger(value)) {
return String(value);
}
const wholePart = Math.floor(value);
const fractionalPart = value - wholePart;
const roundedFrac = roundToFraction(fractionalPart);
if (roundedFrac === 0) {
return String(wholePart || '');
}
if (roundedFrac === 1) {
return String(wholePart + 1);
}
const fracStr = roundedFrac.toFixed(3);
const symbol = FRACTION_MAP[fracStr] || roundedFrac.toFixed(2);
if (wholePart === 0) {
return symbol;
}
return `${wholePart}${symbol}`;
}
function roundToFraction(decimal) {
const fractions = [0, 0.125, 0.25, 0.333, 0.375, 0.5, 0.625, 0.667, 0.75, 0.875, 1];
let closest = 0;
let minDiff = Math.abs(decimal);
for (const frac of fractions) {
const diff = Math.abs(decimal - frac);
if (diff < minDiff) {
minDiff = diff;
closest = frac;
}
}
return closest;
}
function checkPracticalMinimum(value, unit) {
if (!unit || !value) return null;
const normalizedUnit = unit.toLowerCase().replace(/[s.]$/g, '');
const minimum = MIN_PRACTICAL_MEASUREMENTS[normalizedUnit];
if (minimum && value < minimum) {
return `Very small amount - difficult to measure accurately`;
}
if ((normalizedUnit === 'egg' || unit.toLowerCase().includes('egg')) && value < 1 && value > 0) {
return `Partial egg - consider whisking a whole egg and using portion`;
}
return null;
}
function renderScalingControls(recipe) {
const servings = parseServingsYield(recipe.servings_yield);
return `
<div class="scaling-controls">
<span class="scaling-label">Scale recipe:</span>
<div class="scaling-buttons">
<button type="button" class="scale-btn ${recipeScale === 0.25 ? 'active' : ''}" data-scale="0.25">¬º√ó</button>
<button type="button" class="scale-btn ${recipeScale === 0.5 ? 'active' : ''}" data-scale="0.5">¬Ω√ó</button>
<button type="button" class="scale-btn ${recipeScale === 1 ? 'active' : ''}" data-scale="1">1√ó</button>
<button type="button" class="scale-btn ${recipeScale === 2 ? 'active' : ''}" data-scale="2">2√ó</button>
<button type="button" class="scale-btn ${recipeScale === 4 ? 'active' : ''}" data-scale="4">4√ó</button>
</div>
${servings ? `<span class="scaling-servings">${getScaledServings(servings, recipeScale)}</span>` : ''}
</div>
`;
}
function parseServingsYield(servingsYield) {
if (!servingsYield) return null;
const match = servingsYield.match(/(\d+)\s*(servings?|cookies?|pieces?|slices?|cups?|portions?|dozen)?/i);
if (match) {
return {
count: parseInt(match[1]),
unit: match[2] || 'servings',
original: servingsYield
};
}
return null;
}
function getScaledServings(servings, scale) {
if (!servings) return '';
const scaled = Math.round(servings.count * scale);
return `(${scaled} ${servings.unit})`;
}
function setRecipeScale(scale, recipeId) {
recipeScale = scale;
renderRecipeDetail(recipeId);
}
window.setRecipeScale = setRecipeScale;
function findSubstitutes(ingredient) {
if (!substitutionsData || !enableSubstitutions) return [];
const normalized = normalizeIngredientName(ingredient);
const substitutes = [];
for (const rule of substitutionsData.substitutions) {
const primaryMatch = normalizeIngredientName(rule.primary) === normalized;
const aliasMatch = rule.aliases?.some(a => normalizeIngredientName(a) === normalized);
if (primaryMatch || aliasMatch) {
for (const sub of rule.substitutes) {
substitutes.push({
original: rule.primary,
substitute: sub.ingredient,
ratio: sub.ratio,
direction: sub.direction,
notes: sub.notes,
impact: sub.impact,
quality: sub.quality
});
}
}
for (const sub of rule.substitutes) {
if (normalizeIngredientName(sub.ingredient) === normalized) {
substitutes.push({
original: sub.ingredient,
substitute: rule.primary,
ratio: sub.ratio,
direction: sub.direction === 'health' ? 'convenience' : 'health',
notes: sub.notes,
quality: sub.quality
});
}
}
}
return substitutes;
}
function getSubstituteIngredients(ingredient) {
const subs = findSubstitutes(ingredient);
return subs.map(s => s.substitute);
}
function expandStaplesWithSubstitutions(staples) {
if (!substitutionsData || !enableSubstitutions) return staples;
const expanded = new Set(staples);
if (substitutionsData.stapleExpansions?.expansions) {
for (const expansion of substitutionsData.stapleExpansions.expansions) {
const stapleNorm = normalizeIngredientName(expansion.staple);
if (staples.some(s => normalizeIngredientName(s) === stapleNorm)) {
for (const match of expansion.alsoMatches) {
expanded.add(match.toLowerCase());
}
}
}
}
return Array.from(expanded);
}
function findSubstitutionsForIngredient(ingredientName) {
if (!substitutionsData || !substitutionsData.substitutions) return null;
const normalized = normalizeIngredientName(ingredientName);
for (const rule of substitutionsData.substitutions) {
if (normalizeIngredientName(rule.primary) === normalized) {
return rule;
}
if (rule.aliases) {
for (const alias of rule.aliases) {
if (normalizeIngredientName(alias) === normalized) {
return rule;
}
}
}
for (const sub of rule.substitutes) {
if (normalizeIngredientName(sub.ingredient) === normalized) {
return {
primary: sub.ingredient,
substitutes: [{
ingredient: rule.primary,
ratio: reverseRatio(sub.ratio),
direction: sub.direction,
notes: `Original ingredient (reverse of: ${sub.notes || ''})`.trim(),
quality: sub.quality
}],
isReverse: true
};
}
}
}
return null;
}
function reverseRatio(ratio) {
if (!ratio || typeof ratio !== 'string') return '1:1';
const parts = ratio.split(':');
if (parts.length === 2) {
return `${parts[1]}:${parts[0]}`;
}
return ratio;
}
function resetSubstitutions() {
activeSubstitutions = {};
currentRecipeNutrition = null;
renderCurrentRecipe();
}
function applySubstitution(ingredientIndex, originalIng, substitute) {
activeSubstitutions[ingredientIndex] = {
original: originalIng,
substitute: substitute,
nutritionDelta: estimateNutritionDelta(originalIng, substitute)
};
closeSubstitutionModal();
renderCurrentRecipe();
}
function revertSubstitution(ingredientIndex) {
delete activeSubstitutions[ingredientIndex];
renderCurrentRecipe();
}
function estimateNutritionDelta(original, substitute) {
const nutritionEstimates = {
'butter': { calories: 100, fat: 11, carbs: 0, protein: 0 },
'margarine': { calories: 100, fat: 11, carbs: 0, protein: 0 },
'coconut oil': { calories: 120, fat: 14, carbs: 0, protein: 0 },
'applesauce': { calories: 25, fat: 0, carbs: 7, protein: 0 },
'olive oil': { calories: 120, fat: 14, carbs: 0, protein: 0 },
'milk': { calories: 150, fat: 8, carbs: 12, protein: 8 },
'almond milk': { calories: 30, fat: 2.5, carbs: 1, protein: 1 },
'oat milk': { calories: 120, fat: 5, carbs: 16, protein: 3 },
'heavy cream': { calories: 400, fat: 43, carbs: 3, protein: 3 },
'half and half': { calories: 150, fat: 14, carbs: 5, protein: 4 },
'evaporated milk': { calories: 170, fat: 10, carbs: 13, protein: 9 },
'sour cream': { calories: 230, fat: 23, carbs: 5, protein: 3 },
'greek yogurt': { calories: 100, fat: 0, carbs: 6, protein: 17 },
'eggs': { calories: 70, fat: 5, carbs: 0, protein: 6 },
'egg substitute': { calories: 25, fat: 0, carbs: 1, protein: 5 },
'flax egg': { calories: 37, fat: 3, carbs: 2, protein: 1 },
'sugar': { calories: 48, fat: 0, carbs: 12, protein: 0 },
'honey': { calories: 64, fat: 0, carbs: 17, protein: 0 },
'maple syrup': { calories: 52, fat: 0, carbs: 13, protein: 0 },
'stevia': { calories: 0, fat: 0, carbs: 0, protein: 0 },
'swerve': { calories: 0, fat: 0, carbs: 0, protein: 0 },
'monk fruit sweetener': { calories: 0, fat: 0, carbs: 0, protein: 0 },
'parmesan cheese': { calories: 110, fat: 7, carbs: 1, protein: 10 },
'pecorino romano': { calories: 110, fat: 8, carbs: 1, protein: 9 },
'nutritional yeast': { calories: 20, fat: 0, carbs: 1, protein: 3 },
'cream cheese': { calories: 100, fat: 10, carbs: 1, protein: 2 },
'neufchatel cheese': { calories: 70, fat: 6, carbs: 1, protein: 3 },
'flour': { calories: 110, fat: 0, carbs: 23, protein: 3 },
'almond flour': { calories: 160, fat: 14, carbs: 6, protein: 6 },
'coconut flour': { calories: 60, fat: 2, carbs: 8, protein: 2 },
'whole wheat flour': { calories: 100, fat: 1, carbs: 21, protein: 4 },
};
const origName = normalizeIngredientName(original.item || original);
const subName = normalizeIngredientName(substitute.ingredient);
const origNutrition = nutritionEstimates[origName] || null;
const subNutrition = nutritionEstimates[subName] || null;
if (origNutrition && subNutrition) {
return {
calories: subNutrition.calories - origNutrition.calories,
fat: subNutrition.fat - origNutrition.fat,
carbs: subNutrition.carbs - origNutrition.carbs,
protein: subNutrition.protein - origNutrition.protein
};
}
if (substitute.impact) {
const calorieMatch = substitute.impact.match(/(\d+)\s*calories?/i);
if (calorieMatch) {
const cal = parseInt(calorieMatch[1], 10);
if (substitute.impact.toLowerCase().includes('save')) {
return { calories: -cal, fat: 0, carbs: 0, protein: 0 };
}
}
}
return null;
}
function calculateAdjustedNutrition(baseNutrition) {
if (!baseNutrition || !baseNutrition.per_serving) return baseNutrition;
const adjusted = JSON.parse(JSON.stringify(baseNutrition));
let totalDelta = { calories: 0, fat: 0, carbs: 0, protein: 0 };
let hasDeltas = false;
for (const sub of Object.values(activeSubstitutions)) {
if (sub.nutritionDelta) {
totalDelta.calories += sub.nutritionDelta.calories || 0;
totalDelta.fat += sub.nutritionDelta.fat || 0;
totalDelta.carbs += sub.nutritionDelta.carbs || 0;
totalDelta.protein += sub.nutritionDelta.protein || 0;
hasDeltas = true;
}
}
if (!hasDeltas) return baseNutrition;
if (adjusted.per_serving.calories !== null) {
adjusted.per_serving.calories = Math.max(0, Math.round(adjusted.per_serving.calories + totalDelta.calories));
}
if (adjusted.per_serving.fat_g !== null) {
adjusted.per_serving.fat_g = Math.max(0, Math.round((adjusted.per_serving.fat_g + totalDelta.fat) * 10) / 10);
}
if (adjusted.per_serving.carbs_g !== null) {
adjusted.per_serving.carbs_g = Math.max(0, Math.round((adjusted.per_serving.carbs_g + totalDelta.carbs) * 10) / 10);
}
if (adjusted.per_serving.protein_g !== null) {
adjusted.per_serving.protein_g = Math.max(0, Math.round((adjusted.per_serving.protein_g + totalDelta.protein) * 10) / 10);
}
adjusted.substitutionNote = `Adjusted for ${Object.keys(activeSubstitutions).length} substitution(s)`;
return adjusted;
}
function showSubstitutionModal(ingredientIndex, ingredient, rule) {
let modal = document.getElementById('substitution-modal');
if (!modal) {
modal = document.createElement('div');
modal.id = 'substitution-modal';
modal.className = 'modal-overlay';
document.body.appendChild(modal);
}
const isActive = activeSubstitutions[ingredientIndex];
modal.innerHTML = `
<div class="modal-content substitution-modal">
<button class="modal-close" onclick="closeSubstitutionModal()" aria-label="Close">&times;</button>
<h3>Swap Ingredient</h3>
<div class="current-ingredient">
<span class="label">Current:</span>
<span class="ingredient-name">${escapeHtml(isActive ? isActive.substitute.ingredient : ingredient.item)}</span>
${isActive ? '<span class="badge badge-swapped">Swapped</span>' : ''}
</div>
${isActive ? `
<button class="btn btn-secondary revert-btn" onclick="revertSubstitution(${ingredientIndex})">
‚Ü© Revert to ${escapeHtml(isActive.original.item)}
</button>
<hr>
` : ''}
<div class="substitution-options">
<p class="options-label">Available substitutes:</p>
${rule.substitutes.map((sub, idx) => `
<div class="substitution-option" onclick="applySubstitution(${ingredientIndex}, ${escapeAttr(JSON.stringify(ingredient))}, ${escapeAttr(JSON.stringify(sub))})">
<div class="sub-header">
<span class="sub-name">${escapeHtml(sub.ingredient)}</span>
<span class="sub-quality quality-${sub.quality || 'moderate'}">${sub.quality || 'moderate'}</span>
</div>
<div class="sub-details">
<span class="sub-ratio">${escapeHtml(sub.ratio)}</span>
${sub.direction ? `<span class="sub-direction">${escapeHtml(sub.direction)}</span>` : ''}
</div>
${sub.notes ? `<p class="sub-notes">${escapeHtml(sub.notes)}</p>` : ''}
${sub.impact ? `<p class="sub-impact">${escapeHtml(sub.impact)}</p>` : ''}
</div>
`).join('')}
</div>
</div>
`;
modal.classList.add('active');
modal.addEventListener('click', (e) => {
if (e.target === modal) closeSubstitutionModal();
});
document.addEventListener('keydown', handleModalEscape);
}
function handleModalEscape(e) {
if (e.key === 'Escape') closeSubstitutionModal();
}
function closeSubstitutionModal() {
const modal = document.getElementById('substitution-modal');
if (modal) {
modal.classList.remove('active');
}
document.removeEventListener('keydown', handleModalEscape);
}
window.showSubstitutionModal = showSubstitutionModal;
window.closeSubstitutionModal = closeSubstitutionModal;
window.applySubstitution = applySubstitution;
window.revertSubstitution = revertSubstitution;
window.resetSubstitutions = resetSubstitutions;
function parseTimeToMinutes(timeStr) {
if (!timeStr) return null;
const str = timeStr.toLowerCase().trim();
let totalMinutes = 0;
const hourMatch = str.match(/(\d+\.?\d*)\s*(hour|hr|h)/);
if (hourMatch) {
totalMinutes += parseFloat(hourMatch[1]) * 60;
}
const minMatch = str.match(/(\d+)\s*(minute|min|m)(?!i)/);
if (minMatch) {
totalMinutes += parseInt(minMatch[1], 10);
}
if (totalMinutes === 0) {
const justNumber = str.match(/^(\d+)$/);
if (justNumber) {
totalMinutes = parseInt(justNumber[1], 10);
}
}
return totalMinutes > 0 ? totalMinutes : null;
}
function hasActiveNutritionFilter() {
return (
nutritionFilter.calories.min !== null ||
nutritionFilter.calories.max !== null ||
nutritionFilter.carbs.min !== null ||
nutritionFilter.carbs.max !== null ||
nutritionFilter.protein.min !== null ||
nutritionFilter.protein.max !== null ||
nutritionFilter.fat.min !== null ||
nutritionFilter.fat.max !== null
);
}
function applyDietPreset(presetId) {
clearNutritionFilters();
if (presetId === 'clear' || !DIET_PRESETS[presetId]) {
nutritionFilter.activeDietPreset = null;
updateDietPresetButtons();
updateNutritionInputs();
renderRecipeGrid();
return;
}
const preset = DIET_PRESETS[presetId];
nutritionFilter.activeDietPreset = presetId;
if (preset.calories) {
nutritionFilter.calories.min = preset.calories.min || null;
nutritionFilter.calories.max = preset.calories.max || null;
}
if (preset.carbs) {
nutritionFilter.carbs.min = preset.carbs.min || null;
nutritionFilter.carbs.max = preset.carbs.max || null;
}
if (preset.protein) {
nutritionFilter.protein.min = preset.protein.min || null;
nutritionFilter.protein.max = preset.protein.max || null;
}
if (preset.fat) {
nutritionFilter.fat.min = preset.fat.min || null;
nutritionFilter.fat.max = preset.fat.max || null;
}
updateDietPresetButtons();
updateNutritionInputs();
renderRecipeGrid();
}
function clearNutritionFilters() {
nutritionFilter.calories = { min: null, max: null };
nutritionFilter.carbs = { min: null, max: null };
nutritionFilter.protein = { min: null, max: null };
nutritionFilter.fat = { min: null, max: null };
nutritionFilter.activeDietPreset = null;
}
function updateDietPresetButtons() {
document.querySelectorAll('.diet-preset-btn').forEach(btn => {
const preset = btn.dataset.diet;
btn.classList.toggle('active', preset === nutritionFilter.activeDietPreset);
});
}
function updateNutritionInputs() {
const calMin = document.getElementById('cal-min');
const calMax = document.getElementById('cal-max');
const carbsMin = document.getElementById('carbs-min');
const carbsMax = document.getElementById('carbs-max');
const proteinMin = document.getElementById('protein-min');
const proteinMax = document.getElementById('protein-max');
const fatMin = document.getElementById('fat-min');
const fatMax = document.getElementById('fat-max');
if (calMin) calMin.value = nutritionFilter.calories.min ?? '';
if (calMax) calMax.value = nutritionFilter.calories.max ?? '';
if (carbsMin) carbsMin.value = nutritionFilter.carbs.min ?? '';
if (carbsMax) carbsMax.value = nutritionFilter.carbs.max ?? '';
if (proteinMin) proteinMin.value = nutritionFilter.protein.min ?? '';
if (proteinMax) proteinMax.value = nutritionFilter.protein.max ?? '';
if (fatMin) fatMin.value = nutritionFilter.fat.min ?? '';
if (fatMax) fatMax.value = nutritionFilter.fat.max ?? '';
}
function applyCustomNutritionFilters() {
const parseInput = (id) => {
const el = document.getElementById(id);
if (!el || el.value.trim() === '') return null;
const val = parseInt(el.value, 10);
return isNaN(val) ? null : val;
};
nutritionFilter.activeDietPreset = null;
updateDietPresetButtons();
nutritionFilter.calories.min = parseInput('cal-min');
nutritionFilter.calories.max = parseInput('cal-max');
nutritionFilter.carbs.min = parseInput('carbs-min');
nutritionFilter.carbs.max = parseInput('carbs-max');
nutritionFilter.protein.min = parseInput('protein-min');
nutritionFilter.protein.max = parseInput('protein-max');
nutritionFilter.fat.min = parseInput('fat-min');
nutritionFilter.fat.max = parseInput('fat-max');
const onlyWithNutrition = document.getElementById('only-with-nutrition');
nutritionFilter.onlyWithNutrition = onlyWithNutrition?.checked || false;
renderRecipeGrid();
}
function setupNutritionFilters() {
const timeFilter = document.getElementById('time-filter');
if (timeFilter) {
timeFilter.addEventListener('change', (e) => {
nutritionFilter.timeLimit = e.target.value ? parseInt(e.target.value, 10) : null;
renderRecipeGrid();
});
}
const nutritionToggle = document.getElementById('nutrition-toggle');
const nutritionFilters = document.getElementById('nutrition-filters');
if (nutritionToggle && nutritionFilters) {
nutritionToggle.addEventListener('click', () => {
const isExpanded = nutritionToggle.getAttribute('aria-expanded') === 'true';
nutritionToggle.setAttribute('aria-expanded', !isExpanded);
nutritionFilters.classList.toggle('hidden', isExpanded);
nutritionToggle.querySelector('.toggle-icon').textContent = isExpanded ? '‚ñº' : '‚ñ≤';
});
}
document.querySelectorAll('.diet-preset-btn').forEach(btn => {
btn.addEventListener('click', () => {
applyDietPreset(btn.dataset.diet);
});
});
const applyBtn = document.getElementById('apply-nutrition-filter');
if (applyBtn) {
applyBtn.addEventListener('click', applyCustomNutritionFilters);
}
const onlyWithNutrition = document.getElementById('only-with-nutrition');
if (onlyWithNutrition) {
onlyWithNutrition.addEventListener('change', () => {
nutritionFilter.onlyWithNutrition = onlyWithNutrition.checked;
renderRecipeGrid();
});
}
const shoppingToggle = document.getElementById('shopping-toggle');
const shoppingPanel = document.getElementById('shopping-list-panel');
if (shoppingToggle && shoppingPanel) {
shoppingToggle.addEventListener('click', () => {
const isExpanded = shoppingToggle.getAttribute('aria-expanded') === 'true';
shoppingToggle.setAttribute('aria-expanded', !isExpanded);
shoppingPanel.classList.toggle('hidden', isExpanded);
shoppingToggle.querySelector('.toggle-icon').textContent = isExpanded ? '‚ñº' : '‚ñ≤';
});
}
}
function getNutritionStatus(recipe) {
if (!hasActiveNutritionFilter() && !nutritionFilter.activeDietPreset) {
return null;
}
if (!recipe.nutrition) {
return { status: 'warn', message: 'No nutrition data' };
}
const n = recipe.nutrition;
const issues = [];
if (nutritionFilter.calories.max !== null && n.calories > nutritionFilter.calories.max) {
issues.push(`${n.calories} cal (max ${nutritionFilter.calories.max})`);
}
if (nutritionFilter.carbs.max !== null && n.carbohydrates > nutritionFilter.carbs.max) {
issues.push(`${n.carbohydrates}g carbs (max ${nutritionFilter.carbs.max}g)`);
}
if (nutritionFilter.protein.min !== null && n.protein < nutritionFilter.protein.min) {
issues.push(`${n.protein}g protein (min ${nutritionFilter.protein.min}g)`);
}
if (nutritionFilter.fat.max !== null && n.fat > nutritionFilter.fat.max) {
issues.push(`${n.fat}g fat (max ${nutritionFilter.fat.max}g)`);
}
if (issues.length > 0) {
return { status: 'over', message: issues.join(', ') };
}
return { status: 'good', message: 'Meets criteria' };
}
function getMealPairings(recipe, limit = 6) {
if (!recipe || !recipe.category) return [];
const pairingCategories = MEAL_PAIRINGS[recipe.category] || [];
if (pairingCategories.length === 0) return [];
const recipeIngredients = new Set(
(recipe.ingredients || []).map(ing => {
const name = typeof ing === 'string' ? ing : ing.item || ing.name || '';
return normalizeIngredientName(name);
}).filter(Boolean)
);
const candidates = recipes.filter(r => {
if (!pairingCategories.includes(r.category)) return false;
if (r.id === recipe.id) return false;
if (r.variant_of && r.variant_of !== r.id) return false;
return true;
});
const scored = candidates.map(r => {
const rIngredients = (r.ingredients || []).map(ing => {
const name = typeof ing === 'string' ? ing : ing.item || ing.name || '';
return normalizeIngredientName(name);
}).filter(Boolean);
let sharedCount = 0;
for (const ing of rIngredients) {
if (recipeIngredients.has(ing)) sharedCount++;
}
return {
recipe: r,
sharedIngredients: sharedCount,
hasNutrition: r.nutrition ? 1 : 0
};
});
scored.sort((a, b) => {
if (b.sharedIngredients !== a.sharedIngredients) {
return b.sharedIngredients - a.sharedIngredients;
}
return b.hasNutrition - a.hasNutrition;
});
return scored.slice(0, limit).map(s => ({
...s.recipe,
sharedIngredients: s.sharedIngredients
}));
}
function addToShoppingList(recipeId) {
const recipe = recipes.find(r => r.id === recipeId);
if (!recipe) return;
if (!selectedMealRecipes.find(r => r.id === recipeId)) {
selectedMealRecipes.push(recipe);
generateShoppingList();
renderShoppingListPanel();
}
}
function removeFromShoppingList(recipeId) {
selectedMealRecipes = selectedMealRecipes.filter(r => r.id !== recipeId);
generateShoppingList();
renderShoppingListPanel();
}
function generateShoppingList() {
const ingredientMap = new Map();
for (const recipe of selectedMealRecipes) {
if (!recipe.ingredients) continue;
for (const ing of recipe.ingredients) {
let name, quantity, unit;
if (typeof ing === 'string') {
const parsed = parseIngredientString(ing);
name = parsed.name;
quantity = parsed.quantity;
unit = parsed.unit;
} else {
name = ing.item || ing.name || '';
quantity = ing.amount || ing.quantity || '';
unit = ing.unit || '';
}
if (!name) continue;
const normalizedName = normalizeIngredientName(name);
const key = normalizedName;
if (ingredientMap.has(key)) {
const existing = ingredientMap.get(key);
existing.recipes.push(recipe.title);
if (quantity) {
existing.quantities.push({ amount: quantity, unit: unit, recipe: recipe.title });
}
} else {
ingredientMap.set(key, {
name: name,
normalizedName: normalizedName,
recipes: [recipe.title],
quantities: quantity ? [{ amount: quantity, unit: unit, recipe: recipe.title }] : [],
checked: false
});
}
}
}
shoppingList = Array.from(ingredientMap.values());
shoppingList.sort((a, b) => a.name.localeCompare(b.name));
}
function parseIngredientString(str) {
if (!str) return { quantity: '', unit: '', name: '' };
const match = str.match(/^([\d\s\/]+)?\s*(cup|cups|tbsp|tsp|tablespoon|tablespoons|teaspoon|teaspoons|oz|ounce|ounces|lb|lbs|pound|pounds|can|cans|package|packages|pkg|jar|jars|bunch|bunches|clove|cloves|head|heads|slice|slices|piece|pieces)?\s*(.+)?$/i);
if (match) {
return {
quantity: (match[1] || '').trim(),
unit: (match[2] || '').trim(),
name: (match[3] || str).trim()
};
}
return { quantity: '', unit: '', name: str.trim() };
}
function toggleShoppingItem(normalizedName) {
const item = shoppingList.find(i => i.normalizedName === normalizedName);
if (item) {
item.checked = !item.checked;
renderShoppingListPanel();
}
}
function renderShoppingListPanel() {
const panel = document.getElementById('shopping-list-panel');
if (!panel) return;
if (selectedMealRecipes.length === 0) {
panel.innerHTML = `
<div class="shopping-list-empty">
<p>No recipes selected. Add recipes to your meal plan to generate a shopping list.</p>
</div>
`;
return;
}
const recipesHtml = selectedMealRecipes.map(r => `
<div class="shopping-recipe">
<span class="shopping-recipe-title">${escapeHtml(r.title)}</span>
<button type="button" class="shopping-recipe-remove" onclick="removeFromShoppingList('${escapeAttr(r.id)}')" title="Remove">&times;</button>
</div>
`).join('');
const unchecked = shoppingList.filter(i => !i.checked);
const checked = shoppingList.filter(i => i.checked);
const renderItem = (item) => {
const quantityInfo = item.quantities.length > 0
? item.quantities.map(q => `${q.amount} ${q.unit}`.trim()).join(', ')
: '';
const recipeInfo = item.recipes.length > 1
? ` (${item.recipes.join(', ')})`
: '';
return `
<label class="shopping-item ${item.checked ? 'checked' : ''}">
<input type="checkbox" ${item.checked ? 'checked' : ''} onchange="toggleShoppingItem('${escapeAttr(item.normalizedName)}')">
<span class="item-name">${escapeHtml(item.name)}</span>
${quantityInfo ? `<span class="item-quantity">${escapeHtml(quantityInfo)}</span>` : ''}
${recipeInfo ? `<span class="item-recipes">${escapeHtml(recipeInfo)}</span>` : ''}
</label>
`;
};
const itemsHtml = `
${unchecked.map(renderItem).join('')}
${checked.length > 0 ? `
<div class="shopping-list-checked-header">Checked (${checked.length})</div>
${checked.map(renderItem).join('')}
` : ''}
`;
panel.innerHTML = `
<div class="shopping-list-header">
<h3>Meal Plan (${selectedMealRecipes.length} recipes)</h3>
<button type="button" class="btn btn-small" onclick="copyShoppingList()">Copy List</button>
</div>
<div class="shopping-recipes-list">
${recipesHtml}
</div>
<div class="shopping-list-divider"></div>
<div class="shopping-items-header">
<h4>Shopping List (${shoppingList.length} items)</h4>
</div>
<div class="shopping-items-list">
${itemsHtml}
</div>
`;
}
async function copyShoppingList() {
if (shoppingList.length === 0) return;
const lines = ['Shopping List', ''];
lines.push('Recipes:');
for (const r of selectedMealRecipes) {
lines.push(`- ${r.title}`);
}
lines.push('');
lines.push('Ingredients:');
for (const item of shoppingList) {
const quantityInfo = item.quantities.length > 0
? ` (${item.quantities.map(q => `${q.amount} ${q.unit}`.trim()).join(', ')})`
: '';
lines.push(`- ${item.name}${quantityInfo}`);
}
const text = lines.join('\n');
try {
await navigator.clipboard.writeText(text);
showToast('Shopping list copied to clipboard!');
} catch (err) {
const textarea = document.createElement('textarea');
textarea.value = text;
document.body.appendChild(textarea);
textarea.select();
document.execCommand('copy');
document.body.removeChild(textarea);
showToast('Shopping list copied!');
}
}
function showToast(message) {
const existing = document.querySelector('.toast-notification');
if (existing) existing.remove();
const toast = document.createElement('div');
toast.className = 'toast-notification';
toast.textContent = message;
document.body.appendChild(toast);
setTimeout(() => toast.classList.add('show'), 10);
setTimeout(() => {
toast.classList.remove('show');
setTimeout(() => toast.remove(), 300);
}, 2500);
}
async function copyShareableLink() {
const url = new URL(window.location.href);
if (currentFilter.search) {
url.searchParams.set('q', currentFilter.search);
}
if (currentFilter.category) {
url.searchParams.set('cat', currentFilter.category);
}
if (selectedIngredients.length > 0) {
url.searchParams.set('ing', selectedIngredients.join(','));
}
if (nutritionFilter.activeDietPreset) {
url.searchParams.set('diet', nutritionFilter.activeDietPreset);
}
if (nutritionFilter.timeLimit) {
url.searchParams.set('time', nutritionFilter.timeLimit);
}
try {
await navigator.clipboard.writeText(url.toString());
showToast('Link copied to clipboard!');
} catch (err) {
const textarea = document.createElement('textarea');
textarea.value = url.toString();
document.body.appendChild(textarea);
textarea.select();
document.execCommand('copy');
document.body.removeChild(textarea);
showToast('Link copied!');
}
}
function clearShoppingList() {
selectedMealRecipes = [];
shoppingList = [];
renderShoppingListPanel();
}
window.addToShoppingList = addToShoppingList;
window.removeFromShoppingList = removeFromShoppingList;
window.toggleShoppingItem = toggleShoppingItem;
window.copyShoppingList = copyShoppingList;
window.copyShareableLink = copyShareableLink;
window.clearShoppingList = clearShoppingList;
function setupIngredientSearch() {
const input = document.getElementById('ingredient-input');
const searchBtn = document.getElementById('ingredient-search-btn');
const optionsBtn = document.getElementById('ingredient-options-btn');
const optionsPanel = document.getElementById('ingredient-options-panel');
const clearBtn = document.getElementById('clear-ingredient-search');
const autocomplete = document.getElementById('ingredient-autocomplete');
if (!input) return;
input.addEventListener('input', debounce(handleIngredientInput, 150));
input.addEventListener('keydown', handleIngredientKeydown);
input.addEventListener('focus', () => {
if (input.value.length >= 2) {
showAutocomplete(input.value);
}
});
document.addEventListener('click', (e) => {
if (!e.target.closest('.ingredient-input-container')) {
hideAutocomplete();
}
});
if (searchBtn) {
searchBtn.addEventListener('click', performIngredientSearch);
}
if (optionsBtn && optionsPanel) {
optionsBtn.addEventListener('click', () => {
const isExpanded = optionsBtn.getAttribute('aria-expanded') === 'true';
optionsBtn.setAttribute('aria-expanded', !isExpanded);
optionsPanel.classList.toggle('hidden', isExpanded);
});
}
document.querySelectorAll('.option-btn[data-mode]').forEach(btn => {
btn.addEventListener('click', () => {
document.querySelectorAll('.option-btn[data-mode]').forEach(b => b.classList.remove('active'));
btn.classList.add('active');
ingredientSearchOptions.matchMode = btn.dataset.mode;
if (selectedIngredients.length > 0) {
performIngredientSearch();
}
});
});
document.querySelectorAll('.option-btn[data-missing]').forEach(btn => {
btn.addEventListener('click', () => {
document.querySelectorAll('.option-btn[data-missing]').forEach(b => b.classList.remove('active'));
btn.classList.add('active');
ingredientSearchOptions.missingThreshold = parseInt(btn.dataset.missing, 10);
if (selectedIngredients.length > 0) {
performIngredientSearch();
}
});
});
if (clearBtn) {
clearBtn.addEventListener('click', clearIngredientSearch);
}
document.querySelectorAll('.suggestion-chip').forEach(chip => {
chip.addEventListener('click', () => {
const ingredient = chip.dataset.ingredient;
if (!selectedIngredients.includes(ingredient)) {
addSelectedIngredient(ingredient);
performIngredientSearch();
}
});
});
const pageSizeSelect = document.getElementById('results-per-page');
if (pageSizeSelect) {
pageSizeSelect.addEventListener('change', (e) => {
const value = e.target.value;
ingredientResultsPageSize = value === 'all' ? Infinity : parseInt(value, 10);
ingredientResultsShown = 0;
renderIngredientRecipeList();
});
}
const loadMoreBtn = document.getElementById('load-more-recipes');
if (loadMoreBtn) {
loadMoreBtn.addEventListener('click', () => {
loadMoreIngredientResults();
});
}
}
function handleIngredientInput(e) {
const query = e.target.value.trim();
if (query.length < 2) {
hideAutocomplete();
return;
}
showAutocomplete(query);
}
function handleIngredientKeydown(e) {
const autocomplete = document.getElementById('ingredient-autocomplete');
const items = autocomplete.querySelectorAll('.autocomplete-item');
if (autocomplete.classList.contains('hidden') || items.length === 0) {
if (e.key === 'Enter') {
e.preventDefault();
const input = e.target;
const value = input.value.trim();
if (value && !selectedIngredients.includes(value.toLowerCase())) {
addSelectedIngredient(value.toLowerCase());
input.value = '';
hideAutocomplete();
performIngredientSearch();
}
}
return;
}
switch (e.key) {
case 'ArrowDown':
e.preventDefault();
autocompleteHighlightIndex = Math.min(autocompleteHighlightIndex + 1, items.length - 1);
updateAutocompleteHighlight(items);
break;
case 'ArrowUp':
e.preventDefault();
autocompleteHighlightIndex = Math.max(autocompleteHighlightIndex - 1, -1);
updateAutocompleteHighlight(items);
break;
case 'Enter':
e.preventDefault();
if (autocompleteHighlightIndex >= 0 && items[autocompleteHighlightIndex]) {
selectAutocompleteItem(items[autocompleteHighlightIndex]);
} else if (items.length > 0) {
selectAutocompleteItem(items[0]);
}
break;
case 'Escape':
hideAutocomplete();
break;
}
}
function updateAutocompleteHighlight(items) {
items.forEach((item, index) => {
item.classList.toggle('highlighted', index === autocompleteHighlightIndex);
if (index === autocompleteHighlightIndex) {
item.scrollIntoView({ block: 'nearest' });
}
});
}
async function showAutocomplete(query) {
const autocomplete = document.getElementById('ingredient-autocomplete');
if (!autocomplete) return;
if (!ingredientIndex) {
autocomplete.innerHTML = `<div class="autocomplete-item" style="color: var(--color-text-light); cursor: default;">Loading ingredients...</div>`;
autocomplete.classList.remove('hidden');
await loadIngredientIndex();
await loadSubstitutions();
if (!ingredientIndex) {
autocomplete.innerHTML = `<div class="autocomplete-item" style="color: var(--color-text-light); cursor: default;">Failed to load ingredients</div>`;
return;
}
}
const matches = searchIngredients(query, 10);
autocompleteHighlightIndex = -1;
if (matches.length === 0) {
autocomplete.innerHTML = `
<div class="autocomplete-item" style="color: var(--color-text-light); cursor: default;">
No matches found
</div>
`;
autocomplete.classList.remove('hidden');
return;
}
autocomplete.innerHTML = matches.map(match => {
const highlightedName = highlightMatch(match.name, query);
const recipeCount = match.recipeCount;
return `
<div class="autocomplete-item" data-ingredient="${escapeAttr(match.name)}" role="option">
<span class="autocomplete-item-name">${highlightedName}</span>
<span class="autocomplete-item-count">${recipeCount} recipe${recipeCount !== 1 ? 's' : ''}</span>
</div>
`;
}).join('');
autocomplete.querySelectorAll('.autocomplete-item[data-ingredient]').forEach(item => {
item.addEventListener('click', () => selectAutocompleteItem(item));
});
autocomplete.classList.remove('hidden');
}
function hideAutocomplete() {
const autocomplete = document.getElementById('ingredient-autocomplete');
if (autocomplete) {
autocomplete.classList.add('hidden');
autocompleteHighlightIndex = -1;
}
}
function selectAutocompleteItem(item) {
const ingredient = item.dataset.ingredient;
if (!ingredient) return;
const input = document.getElementById('ingredient-input');
if (input) {
input.value = '';
input.focus();
}
if (!selectedIngredients.includes(ingredient)) {
addSelectedIngredient(ingredient);
performIngredientSearch();
}
hideAutocomplete();
}
function getCanonicalName(name) {
if (!ingredientIndex) return name;
const lower = name.toLowerCase().trim();
return ingredientIndex.synonyms[lower] || lower;
}
function searchIngredients(query, limit = 10) {
if (!ingredientIndex || !query) return [];
const queryLower = query.toLowerCase().trim();
const results = [];
const seen = new Set();
for (const canonical of Object.keys(ingredientIndex.ingredients)) {
if (selectedIngredients.some(s => getCanonicalName(s) === canonical)) continue;
const score = fuzzyMatch(canonical, queryLower);
if (score > 0 && !seen.has(canonical)) {
seen.add(canonical);
const recipeIds = ingredientIndex.ingredients[canonical] || [];
results.push({
name: canonical,
canonical: canonical,
score: score,
recipeCount: recipeIds.length
});
}
}
for (const [variant, canonical] of Object.entries(ingredientIndex.synonyms)) {
if (seen.has(canonical)) continue;
if (selectedIngredients.some(s => getCanonicalName(s) === canonical)) continue;
const score = fuzzyMatch(variant, queryLower);
if (score > 0) {
seen.add(canonical);
const recipeIds = ingredientIndex.ingredients[canonical] || [];
results.push({
name: canonical,
canonical: canonical,
score: score,
recipeCount: recipeIds.length
});
}
}
results.sort((a, b) => {
if (b.score !== a.score) return b.score - a.score;
return b.recipeCount - a.recipeCount;
});
return results.slice(0, limit);
}
function fuzzyMatch(text, query) {
const textLower = text.toLowerCase();
const queryLower = query.toLowerCase();
if (textLower === queryLower) return 100;
if (textLower.startsWith(queryLower)) return 90;
const wordBoundaryRegex = new RegExp(`\\b${escapeRegex(queryLower)}`);
if (wordBoundaryRegex.test(textLower)) return 80;
if (textLower.includes(queryLower)) return 70;
const words = textLower.split(/\s+/);
for (const word of words) {
if (word.startsWith(queryLower)) return 60;
}
let queryIdx = 0;
for (let i = 0; i < textLower.length && queryIdx < queryLower.length; i++) {
if (textLower[i] === queryLower[queryIdx]) {
queryIdx++;
}
}
if (queryIdx === queryLower.length) {
return 30;
}
return 0;
}
function escapeRegex(str) {
return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
function highlightMatch(text, query) {
if (!query) return escapeHtml(text);
const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
const parts = text.split(regex);
return parts.map(part => {
if (part.toLowerCase() === query.toLowerCase()) {
return `<span class="autocomplete-match">${escapeHtml(part)}</span>`;
}
return escapeHtml(part);
}).join('');
}
function addSelectedIngredient(ingredient) {
if (selectedIngredients.includes(ingredient)) return;
selectedIngredients.push(ingredient);
renderSelectedIngredients();
}
function removeSelectedIngredient(ingredient) {
selectedIngredients = selectedIngredients.filter(i => i !== ingredient);
renderSelectedIngredients();
performIngredientSearch();
}
function renderSelectedIngredients() {
const container = document.getElementById('selected-ingredients');
if (!container) return;
if (selectedIngredients.length === 0) {
container.classList.add('hidden');
container.innerHTML = '';
return;
}
container.classList.remove('hidden');
container.innerHTML = selectedIngredients.map(ing => `
<span class="ingredient-pill">
${escapeHtml(ing)}
<button type="button" class="ingredient-pill-remove" data-ingredient="${escapeAttr(ing)}" aria-label="Remove ${escapeAttr(ing)}">
&times;
</button>
</span>
`).join('');
container.querySelectorAll('.ingredient-pill-remove').forEach(btn => {
btn.addEventListener('click', () => {
removeSelectedIngredient(btn.dataset.ingredient);
});
});
}
function clearIngredientSearch() {
selectedIngredients = [];
searchKeywords = [];
renderSelectedIngredients();
const input = document.getElementById('ingredient-input');
if (input) input.value = '';
const resultsDiv = document.getElementById('ingredient-search-results');
if (resultsDiv) resultsDiv.classList.add('hidden');
const recipeGrid = document.getElementById('recipe-grid');
if (recipeGrid) recipeGrid.classList.remove('hidden');
const recipeList = document.getElementById('ingredient-recipe-list');
if (recipeList) recipeList.innerHTML = '';
justStaplesMode = false;
const justStaplesBtn = document.getElementById('just-staples-btn');
if (justStaplesBtn) {
justStaplesBtn.classList.remove('active');
justStaplesBtn.textContent = 'Just Staples';
}
currentFilter.ingredients = [];
currentFilter.ingredientMatchInfo = null;
currentFilter.keywords = [];
renderRecipeGrid();
}
function performIngredientSearch() {
const effectiveIngredients = getEffectiveIngredients();
if (effectiveIngredients.length === 0 && !justStaplesMode) {
clearIngredientSearch();
return;
}
const matchInfo = findRecipesByIngredients(
effectiveIngredients,
ingredientSearchOptions.matchMode,
ingredientSearchOptions.missingThreshold
);
currentFilter.ingredients = effectiveIngredients;
currentFilter.ingredientMatchInfo = matchInfo;
updateIngredientSearchResults(matchInfo);
calculateAndDisplaySuggestions(effectiveIngredients, matchInfo);
renderRecipeGrid();
}
function findRecipesByIngredients(ingredients, matchMode, missingThreshold) {
if (!ingredientIndex || ingredients.length === 0) {
return { matches: [], perfectMatches: 0, partialMatches: 0 };
}
const ingredientData = ingredientIndex.ingredients || {};
const recipeMatches = new Map();
const allIngredientKeys = Object.keys(ingredientData);
for (const selectedIng of ingredients) {
const normalizedSelected = normalizeIngredientName(selectedIng);
const canonical = getCanonicalName(normalizedSelected);
const matchingRecipeIds = new Set();
if (ingredientData[normalizedSelected]) {
for (const recipeId of ingredientData[normalizedSelected]) {
matchingRecipeIds.add(recipeId);
}
}
if (ingredientData[canonical] && canonical !== normalizedSelected) {
for (const recipeId of ingredientData[canonical]) {
matchingRecipeIds.add(recipeId);
}
}
if (matchingRecipeIds.size === 0 && normalizedSelected.length >= 3) {
for (const ingName of allIngredientKeys) {
if (ingName.includes(normalizedSelected) || normalizedSelected.includes(ingName)) {
for (const recipeId of ingredientData[ingName]) {
matchingRecipeIds.add(recipeId);
}
}
if (matchingRecipeIds.size > 5000) break;
}
}
for (const recipeId of matchingRecipeIds) {
if (!recipeMatches.has(recipeId)) {
recipeMatches.set(recipeId, {
matchCount: 0,
matchedIngredients: [],
missingIngredients: [],
substitutionMatches: []
});
}
const info = recipeMatches.get(recipeId);
info.matchCount++;
info.matchedIngredients.push(selectedIng);
}
}
for (const [recipeId, info] of recipeMatches) {
for (const selectedIng of ingredients) {
if (!info.matchedIngredients.includes(selectedIng)) {
info.missingIngredients.push(selectedIng);
}
}
}
const results = [];
const validRecipeIds = new Set(recipes.map(r => r.id));
for (const [recipeId, info] of recipeMatches) {
if (!validRecipeIds.has(recipeId)) continue;
const recipe = recipes.find(r => r.id === recipeId);
if (recipe && recipe.variant_of && recipe.variant_of !== recipe.id) continue;
let isMatch = false;
if (matchMode === 'any') {
isMatch = info.matchCount > 0;
} else {
const requiredMatches = Math.max(1, ingredients.length - missingThreshold);
isMatch = info.matchCount >= requiredMatches;
}
if (isMatch) {
results.push({
recipeId: recipeId,
matchCount: info.matchCount,
totalSelected: ingredients.length,
matchedIngredients: info.matchedIngredients,
missingIngredients: info.missingIngredients,
substitutionMatches: info.substitutionMatches,
hasSubstitutions: info.substitutionMatches.length > 0,
isPerfectMatch: info.matchCount === ingredients.length
});
}
}
results.sort((a, b) => {
if (b.matchCount !== a.matchCount) return b.matchCount - a.matchCount;
const recipeA = recipes.find(r => r.id === a.recipeId);
const recipeB = recipes.find(r => r.id === b.recipeId);
return (recipeA?.title || '').localeCompare(recipeB?.title || '');
});
const perfectMatches = results.filter(r => r.isPerfectMatch).length;
const partialMatches = results.filter(r => !r.isPerfectMatch).length;
return {
matches: results,
perfectMatches: perfectMatches,
partialMatches: partialMatches
};
}
function normalizeIngredientName(name) {
if (!name) return '';
return name.toLowerCase()
.replace(/[,()]/g, '')
.replace(/\s+/g, ' ')
.trim();
}
function updateIngredientSearchResults(matchInfo) {
const resultsDiv = document.getElementById('ingredient-search-results');
const countSpan = document.getElementById('ingredient-match-count');
const recipeGrid = document.getElementById('recipe-grid');
if (!resultsDiv || !countSpan) return;
const total = matchInfo.matches.length;
currentIngredientMatches = matchInfo.matches;
ingredientResultsShown = 0;
if (recipeGrid) {
recipeGrid.classList.add('hidden');
}
if (total === 0) {
countSpan.innerHTML = 'No recipes found with those ingredients';
const recipeList = document.getElementById('ingredient-recipe-list');
if (recipeList) recipeList.innerHTML = '';
const loadMoreContainer = document.getElementById('load-more-container');
if (loadMoreContainer) loadMoreContainer.classList.add('hidden');
} else {
let text = `Found <span class="match-count-number">${total}</span> recipe${total !== 1 ? 's' : ''}`;
if (matchInfo.perfectMatches > 0 && matchInfo.partialMatches > 0) {
text += ` (${matchInfo.perfectMatches} perfect match${matchInfo.perfectMatches !== 1 ? 'es' : ''}, ${matchInfo.partialMatches} partial)`;
}
countSpan.innerHTML = text;
renderIngredientRecipeList();
}
resultsDiv.classList.remove('hidden');
}
function renderIngredientRecipeList() {
const recipeList = document.getElementById('ingredient-recipe-list');
const loadMoreContainer = document.getElementById('load-more-container');
const loadMoreStatus = document.getElementById('load-more-status');
if (!recipeList) return;
const sortedMatches = [...currentIngredientMatches].sort((a, b) => {
if (a.isPerfectMatch && !b.isPerfectMatch) return -1;
if (!a.isPerfectMatch && b.isPerfectMatch) return 1;
return b.matchPercent - a.matchPercent;
});
const endIndex = Math.min(ingredientResultsShown + ingredientResultsPageSize, sortedMatches.length);
const recipesToShow = sortedMatches.slice(ingredientResultsShown, endIndex);
if (ingredientResultsShown === 0) {
recipeList.innerHTML = '';
}
recipesToShow.forEach(match => {
const recipe = recipes.find(r => r.id === match.recipeId);
if (!recipe) return;
const card = createIngredientResultCard(recipe, match);
recipeList.appendChild(card);
});
ingredientResultsShown = endIndex;
if (loadMoreContainer && loadMoreStatus) {
const remaining = sortedMatches.length - ingredientResultsShown;
if (remaining > 0) {
loadMoreContainer.classList.remove('hidden');
loadMoreStatus.textContent = `Showing ${ingredientResultsShown} of ${sortedMatches.length}`;
} else {
loadMoreContainer.classList.add('hidden');
}
}
}
function loadMoreIngredientResults() {
renderIngredientRecipeList();
}
function createIngredientResultCard(recipe, match) {
const card = document.createElement('div');
card.className = 'ingredient-result-card';
if (match.isPerfectMatch) {
card.classList.add('perfect-match');
}
const hasImage = recipe.image_refs && recipe.image_refs.length > 0;
const imageSrc = hasImage ? `data/${recipe.image_refs[0]}` : null;
let matchInfo = '';
if (match.isPerfectMatch) {
matchInfo = '<span class="match-badge perfect">Perfect Match</span>';
} else {
matchInfo = `<span class="match-badge partial">${match.matchedCount}/${match.totalInRecipe} ingredients</span>`;
}
const matchedList = match.matchedIngredients
.slice(0, 5)
.map(ing => escapeHtml(ing))
.join(', ');
const moreMatched = match.matchedIngredients.length > 5
? ` +${match.matchedIngredients.length - 5} more`
: '';
let missingHtml = '';
if (match.missingIngredients && match.missingIngredients.length > 0) {
const missingList = match.missingIngredients
.slice(0, 3)
.map(ing => escapeHtml(ing))
.join(', ');
const moreMissing = match.missingIngredients.length > 3
? ` +${match.missingIngredients.length - 3} more`
: '';
missingHtml = `<div class="missing-ingredients">Missing: ${missingList}${moreMissing}</div>`;
}
let substitutionHtml = '';
if (match.substitutionMatches && match.substitutionMatches.length > 0) {
const subList = match.substitutionMatches
.slice(0, 2)
.map(s => `${escapeHtml(s.userHas)} ‚Üí ${escapeHtml(s.recipeNeeds)}`)
.join(', ');
substitutionHtml = `<div class="substitution-info">Substitutions: ${subList}</div>`;
}
card.innerHTML = `
<div class="result-card-image${hasImage ? '' : ' no-image'}">
${hasImage ? `<img src="${escapeAttr(imageSrc)}" alt="${escapeAttr(recipe.title)}" loading="lazy"
onerror="this.parentElement.classList.add('no-image'); this.style.display='none';">` : ''}
</div>
<div class="result-card-content">
<div class="result-card-header">
<h4 class="result-card-title">${escapeHtml(recipe.title)}</h4>
${matchInfo}
</div>
<div class="result-card-category">${escapeHtml(recipe.category || 'Uncategorized')}</div>
<div class="matched-ingredients">Have: ${matchedList}${moreMatched}</div>
${missingHtml}
${substitutionHtml}
<a href="recipe.html?id=${escapeAttr(recipe.id)}" class="result-card-link">View Recipe</a>
</div>
`;
return card;
}
function calculateAndDisplaySuggestions(currentIngredients, matchInfo) {
const suggestionsPanel = document.getElementById('ingredient-suggestions');
const addSuggestionsDiv = document.getElementById('add-suggestions');
const addSuggestionsList = document.getElementById('add-suggestions-list');
const removeSuggestionsDiv = document.getElementById('remove-suggestions');
const removeSuggestionsList = document.getElementById('remove-suggestions-list');
if (!suggestionsPanel || !addSuggestionsDiv || !removeSuggestionsDiv) return;
if (currentIngredients.length === 0) {
suggestionsPanel.classList.add('hidden');
return;
}
const addSuggestions = calculateAddSuggestions(currentIngredients, matchInfo, 5);
const removeSuggestions = calculateRemoveSuggestions(currentIngredients, 3);
if (addSuggestions.length > 0) {
addSuggestionsList.innerHTML = addSuggestions.map(s => `
<button type="button" class="suggestion-add-chip" data-ingredient="${escapeAttr(s.ingredient)}">
+${escapeHtml(s.ingredient)} <span class="chip-count">(${s.newRecipes} more)</span>
</button>
`).join('');
addSuggestionsList.querySelectorAll('.suggestion-add-chip').forEach(chip => {
chip.addEventListener('click', () => {
const ingredient = chip.dataset.ingredient;
if (!selectedIngredients.includes(ingredient)) {
addSelectedIngredient(ingredient);
performIngredientSearch();
}
});
});
addSuggestionsDiv.classList.remove('hidden');
} else {
addSuggestionsDiv.classList.add('hidden');
}
if (removeSuggestions.length > 0 && selectedIngredients.length > 1) {
removeSuggestionsList.innerHTML = removeSuggestions.map(s => `
<button type="button" class="suggestion-remove-chip" data-ingredient="${escapeAttr(s.ingredient)}">
-${escapeHtml(s.ingredient)} <span class="chip-count">(${s.newRecipes} more)</span>
</button>
`).join('');
removeSuggestionsList.querySelectorAll('.suggestion-remove-chip').forEach(chip => {
chip.addEventListener('click', () => {
const ingredient = chip.dataset.ingredient;
removeSelectedIngredient(ingredient);
});
});
removeSuggestionsDiv.classList.remove('hidden');
} else {
removeSuggestionsDiv.classList.add('hidden');
}
if (addSuggestions.length > 0 || (removeSuggestions.length > 0 && selectedIngredients.length > 1)) {
suggestionsPanel.classList.remove('hidden');
} else {
suggestionsPanel.classList.add('hidden');
}
}
function calculateAddSuggestions(currentIngredients, matchInfo, limit = 5) {
if (!ingredientIndex) return [];
const currentMatches = new Set(matchInfo.matches.map(m => m.recipeId));
const ingredientGains = {};
for (const recipe of recipes) {
if (recipe.variant_of && recipe.variant_of !== recipe.id) continue;
if (currentMatches.has(recipe.id)) continue;
const recipeIngredients = recipe.ingredients || [];
for (const ing of recipeIngredients) {
const normalized = normalizeIngredientName(ing.item);
if (currentIngredients.some(ci => {
const ciNorm = normalizeIngredientName(ci);
return ciNorm === normalized || normalized.includes(ciNorm) || ciNorm.includes(normalized);
})) continue;
if (!ingredientGains[normalized]) {
ingredientGains[normalized] = new Set();
}
ingredientGains[normalized].add(recipe.id);
}
}
const suggestions = Object.entries(ingredientGains)
.map(([ingredient, recipeSet]) => ({
ingredient,
newRecipes: recipeSet.size
}))
.filter(s => s.newRecipes >= 2)
.sort((a, b) => b.newRecipes - a.newRecipes)
.slice(0, limit);
return suggestions;
}
function calculateRemoveSuggestions(currentIngredients, limit = 3) {
if (currentIngredients.length <= 1) return [];
const suggestions = [];
for (const ingredient of currentIngredients) {
if (userStaples.includes(ingredient)) continue;
if (!selectedIngredients.includes(ingredient)) continue;
const withoutThis = currentIngredients.filter(i => i !== ingredient);
if (withoutThis.length === 0) continue;
const matchInfo = findRecipesByIngredients(
withoutThis,
ingredientSearchOptions.matchMode,
ingredientSearchOptions.missingThreshold
);
const currentMatchCount = currentFilter.ingredientMatchInfo?.matches.length || 0;
const newMatchCount = matchInfo.matches.length;
const gain = newMatchCount - currentMatchCount;
if (gain > 0) {
suggestions.push({
ingredient,
newRecipes: gain
});
}
}
return suggestions
.sort((a, b) => b.newRecipes - a.newRecipes)
.slice(0, limit);
}
function setupStaplesSystem() {
loadStaples();
const includeStaplesCheckbox = document.getElementById('include-staples');
const justStaplesBtn = document.getElementById('just-staples-btn');
const editStaplesBtn = document.getElementById('edit-staples-btn');
const staplesEditor = document.getElementById('staples-editor');
const staplesInput = document.getElementById('staples-input');
const addStapleBtn = document.getElementById('add-staple-btn');
const clearStaplesBtn = document.getElementById('clear-staples-btn');
const closeStaplesBtn = document.getElementById('close-staples-btn');
if (!includeStaplesCheckbox) return;
includeStaplesCheckbox.checked = includeStaples;
includeStaplesCheckbox.addEventListener('change', (e) => {
includeStaples = e.target.checked;
saveStaplesPreferences();
if (selectedIngredients.length > 0 || justStaplesMode) {
performIngredientSearch();
}
});
if (justStaplesBtn) {
justStaplesBtn.addEventListener('click', toggleJustStaplesMode);
}
if (editStaplesBtn && staplesEditor) {
editStaplesBtn.addEventListener('click', () => {
staplesEditor.classList.toggle('hidden');
editStaplesBtn.textContent = staplesEditor.classList.contains('hidden') ? 'Edit Staples' : 'Hide Editor';
});
}
if (closeStaplesBtn && staplesEditor) {
closeStaplesBtn.addEventListener('click', () => {
staplesEditor.classList.add('hidden');
if (editStaplesBtn) editStaplesBtn.textContent = 'Edit Staples';
});
}
if (staplesInput && addStapleBtn) {
addStapleBtn.addEventListener('click', () => {
const value = staplesInput.value.trim().toLowerCase();
if (value && !userStaples.includes(value)) {
addStaple(value);
staplesInput.value = '';
}
});
staplesInput.addEventListener('keydown', (e) => {
if (e.key === 'Enter') {
e.preventDefault();
const value = staplesInput.value.trim().toLowerCase();
if (value && !userStaples.includes(value)) {
addStaple(value);
staplesInput.value = '';
}
}
});
}
if (clearStaplesBtn) {
clearStaplesBtn.addEventListener('click', () => {
if (confirm('Clear all staples? This cannot be undone.')) {
userStaples = [];
saveStaples();
renderStaplesList();
updateStaplesCount();
}
});
}
document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
btn.addEventListener('click', () => {
const preset = btn.dataset.preset;
if (STAPLES_PRESETS[preset]) {
addPresetStaples(preset);
}
});
});
renderStaplesList();
updateStaplesCount();
}
function toggleJustStaplesMode() {
const justStaplesBtn = document.getElementById('just-staples-btn');
justStaplesMode = !justStaplesMode;
if (justStaplesBtn) {
justStaplesBtn.classList.toggle('active', justStaplesMode);
justStaplesBtn.textContent = justStaplesMode ? 'Exit Just Staples' : 'Just Staples';
}
if (justStaplesMode) {
performIngredientSearch();
} else {
if (selectedIngredients.length === 0) {
clearIngredientSearch();
} else {
performIngredientSearch();
}
}
}
function addStaple(ingredient) {
const normalized = ingredient.toLowerCase().trim();
if (!userStaples.includes(normalized)) {
userStaples.push(normalized);
userStaples.sort();
saveStaples();
renderStaplesList();
updateStaplesCount();
}
}
function removeStaple(ingredient) {
userStaples = userStaples.filter(s => s !== ingredient);
saveStaples();
renderStaplesList();
updateStaplesCount();
}
function addPresetStaples(presetName) {
const preset = STAPLES_PRESETS[presetName];
if (!preset) return;
let addedCount = 0;
preset.forEach(ingredient => {
const normalized = ingredient.toLowerCase().trim();
if (!userStaples.includes(normalized)) {
userStaples.push(normalized);
addedCount++;
}
});
if (addedCount > 0) {
userStaples.sort();
saveStaples();
renderStaplesList();
updateStaplesCount();
}
}
function renderStaplesList() {
const container = document.getElementById('staples-list');
if (!container) return;
if (userStaples.length === 0) {
container.innerHTML = '<span style="opacity: 0.6; font-size: 0.85rem;">No staples yet. Add some above!</span>';
return;
}
container.innerHTML = userStaples.map(staple => `
<span class="staple-pill">
${escapeHtml(staple)}
<button type="button" class="staple-pill-remove" data-staple="${escapeAttr(staple)}" aria-label="Remove ${escapeAttr(staple)}">
&times;
</button>
</span>
`).join('');
container.querySelectorAll('.staple-pill-remove').forEach(btn => {
btn.addEventListener('click', () => {
removeStaple(btn.dataset.staple);
});
});
}
function updateStaplesCount() {
const countSpan = document.getElementById('staples-count');
if (countSpan) {
countSpan.textContent = `(${userStaples.length} item${userStaples.length !== 1 ? 's' : ''})`;
}
}
function saveStaples() {
try {
localStorage.setItem('grandmas-kitchen-staples', JSON.stringify(userStaples));
} catch (e) {
console.warn('Could not save staples:', e);
}
}
function loadStaples() {
try {
const saved = localStorage.getItem('grandmas-kitchen-staples');
if (saved) {
const parsed = JSON.parse(saved);
if (Array.isArray(parsed)) {
userStaples = parsed;
}
}
const prefs = localStorage.getItem('grandmas-kitchen-staples-prefs');
if (prefs) {
const parsed = JSON.parse(prefs);
if (typeof parsed.includeStaples === 'boolean') {
includeStaples = parsed.includeStaples;
}
}
} catch (e) {
console.warn('Could not load staples:', e);
}
}
function saveStaplesPreferences() {
try {
localStorage.setItem('grandmas-kitchen-staples-prefs', JSON.stringify({
includeStaples: includeStaples
}));
} catch (e) {
console.warn('Could not save staples preferences:', e);
}
}
function getEffectiveIngredients() {
let staples = [...userStaples];
if (enableSubstitutions && staples.length > 0) {
staples = expandStaplesWithSubstitutions(staples);
}
if (justStaplesMode) {
return staples;
}
if (includeStaples && staples.length > 0) {
const combined = [...selectedIngredients];
staples.forEach(staple => {
if (!combined.includes(staple)) {
combined.push(staple);
}
});
return combined;
}
return [...selectedIngredients];
}
function updateCollectionCounts() {
const collectionFilters = document.getElementById('collection-filters');
if (!collectionFilters) return;
const counts = {
'grandma-baker': 0,
'mommom-baker': 0,
'granny-hudson': 0,
'all': 0
};
recipes.forEach(recipe => {
if (recipe.variant_of && recipe.variant_of !== recipe.id) return;
const collection = recipe.collection || '';
if (counts.hasOwnProperty(collection)) {
counts[collection]++;
}
});
Object.keys(counts).forEach(collection => {
const countSpan = collectionFilters.querySelector(`.collection-count[data-count="${collection}"]`);
if (countSpan) {
countSpan.textContent = `(${counts[collection]})`;
}
});
}
function updateCollectionFilter() {
const collectionFilters = document.getElementById('collection-filters');
if (!collectionFilters) return;
const selectedCollections = [];
collectionFilters.querySelectorAll('input[type="checkbox"][data-collection]:checked').forEach(checkbox => {
selectedCollections.push(checkbox.dataset.collection);
});
currentFilter.collections = selectedCollections;
const selectAllBtn = document.getElementById('collection-select-all');
if (selectAllBtn) {
const allCheckboxes = collectionFilters.querySelectorAll('input[type="checkbox"][data-collection]');
const allChecked = Array.from(allCheckboxes).every(cb => cb.checked);
selectAllBtn.textContent = allChecked ? 'Clear All' : 'Select All';
}
}
function saveCollectionPreferences() {
try {
localStorage.setItem('grandmas-kitchen-collections', JSON.stringify(currentFilter.collections));
} catch (e) {
console.warn('Could not save collection preferences:', e);
}
}
function loadCollectionPreferences() {
const collectionFilters = document.getElementById('collection-filters');
if (!collectionFilters) return;
try {
const saved = localStorage.getItem('grandmas-kitchen-collections');
if (saved) {
const savedCollections = JSON.parse(saved);
if (Array.isArray(savedCollections)) {
collectionFilters.querySelectorAll('input[type="checkbox"][data-collection]').forEach(checkbox => {
checkbox.checked = savedCollections.includes(checkbox.dataset.collection);
});
currentFilter.collections = savedCollections;
}
}
} catch (e) {
console.warn('Could not load collection preferences:', e);
}
}
function setupEventListeners() {
const searchForm = document.getElementById('search-form');
if (searchForm) {
searchForm.addEventListener('submit', async (e) => {
e.preventDefault();
const query = document.getElementById('search-input').value;
currentFilter.search = query.toLowerCase();
pagefindSearchResults = await searchWithPagefind(query);
renderRecipeGrid();
});
}
const searchInput = document.getElementById('search-input');
if (searchInput) {
searchInput.addEventListener('input', debounce(async (e) => {
const query = e.target.value;
currentFilter.search = query.toLowerCase();
pagefindSearchResults = await searchWithPagefind(query);
renderRecipeGrid();
}, 300));
}
const categorySelect = document.getElementById('category-filter');
if (categorySelect) {
categorySelect.addEventListener('change', (e) => {
currentFilter.category = e.target.value;
renderRecipeGrid();
});
}
const printBtn = document.getElementById('print-btn');
if (printBtn) {
printBtn.addEventListener('click', () => window.print());
}
const collectionFilters = document.getElementById('collection-filters');
if (collectionFilters) {
loadCollectionPreferences();
collectionFilters.querySelectorAll('input[type="checkbox"][data-collection]').forEach(checkbox => {
checkbox.addEventListener('change', () => {
updateCollectionFilter();
saveCollectionPreferences();
renderTagFilters();
renderRecipeGrid();
});
});
const selectAllBtn = document.getElementById('collection-select-all');
if (selectAllBtn) {
selectAllBtn.addEventListener('click', () => {
const checkboxes = collectionFilters.querySelectorAll('input[type="checkbox"][data-collection]');
const allChecked = Array.from(checkboxes).every(cb => cb.checked);
checkboxes.forEach(cb => {
cb.checked = !allChecked;
});
selectAllBtn.textContent = allChecked ? 'Select All' : 'Clear All';
updateCollectionFilter();
saveCollectionPreferences();
renderRecipeGrid();
});
}
updateCollectionFilter();
}
const tagsToggle = document.getElementById('tags-toggle');
const tagFilters = document.getElementById('tag-filters');
if (tagsToggle && tagFilters) {
tagsToggle.addEventListener('click', () => {
const isExpanded = tagsToggle.getAttribute('aria-expanded') === 'true';
tagsToggle.setAttribute('aria-expanded', !isExpanded);
tagFilters.classList.toggle('collapsed', isExpanded);
});
}
setupKeyboardShortcuts();
loadUrlState();
loadFavorites();
}
function setupKeyboardShortcuts() {
document.addEventListener('keydown', (e) => {
if (e.target.matches('input, textarea, select')) return;
switch (e.key) {
case '/':
e.preventDefault();
const searchInput = document.getElementById('search-input') ||
document.getElementById('ingredient-input');
if (searchInput) {
searchInput.focus();
}
break;
case '?':
if (!e.shiftKey) break;
e.preventDefault();
showKeyboardShortcutsHelp();
break;
case 'Escape':
const activeElement = document.activeElement;
if (activeElement && activeElement.matches('input')) {
activeElement.blur();
}
hideAutocomplete();
break;
case 'h':
if (!e.ctrlKey && !e.metaKey) {
window.location.href = 'index.html';
}
break;
case 'r':
if (!e.ctrlKey && !e.metaKey) {
showRandomRecipe();
}
break;
}
});
}
function showKeyboardShortcutsHelp() {
const existing = document.querySelector('.shortcuts-modal');
if (existing) {
existing.remove();
return;
}
const modal = document.createElement('div');
modal.className = 'shortcuts-modal';
modal.innerHTML = `
<div class="shortcuts-content">
<h3>Keyboard Shortcuts</h3>
<ul>
<li><kbd>/</kbd> Focus search</li>
<li><kbd>Esc</kbd> Clear focus / close</li>
<li><kbd>h</kbd> Go to home</li>
<li><kbd>r</kbd> Random recipe</li>
<li><kbd>Shift</kbd> + <kbd>?</kbd> Show this help</li>
</ul>
<button class="btn btn-small" onclick="this.closest('.shortcuts-modal').remove()">Close</button>
</div>
`;
document.body.appendChild(modal);
modal.addEventListener('click', (e) => {
if (e.target === modal) modal.remove();
});
}
function showRandomRecipe() {
if (recipes.length === 0) return;
const canonical = recipes.filter(r => !r.variant_of || r.variant_of === r.id);
const random = canonical[Math.floor(Math.random() * canonical.length)];
if (random) {
window.location.href = `recipe.html#${random.id}`;
}
}
const FAVORITES_KEY = 'grandmas-kitchen-favorites';
const RECENTLY_VIEWED_KEY = 'grandmas-kitchen-recent';
let favorites = [];
let recentlyViewed = [];
function loadFavorites() {
try {
const saved = localStorage.getItem(FAVORITES_KEY);
favorites = saved ? JSON.parse(saved) : [];
const recent = localStorage.getItem(RECENTLY_VIEWED_KEY);
recentlyViewed = recent ? JSON.parse(recent) : [];
} catch (e) {
favorites = [];
recentlyViewed = [];
}
}
function saveFavorites() {
try {
localStorage.setItem(FAVORITES_KEY, JSON.stringify(favorites));
} catch (e) {
console.error('Failed to save favorites:', e);
}
}
function toggleFavorite(recipeId) {
const index = favorites.indexOf(recipeId);
if (index > -1) {
favorites.splice(index, 1);
} else {
favorites.push(recipeId);
}
saveFavorites();
return favorites.includes(recipeId);
}
function isFavorite(recipeId) {
return favorites.includes(recipeId);
}
function addToRecentlyViewed(recipeId) {
recentlyViewed = recentlyViewed.filter(id => id !== recipeId);
recentlyViewed.unshift(recipeId);
recentlyViewed = recentlyViewed.slice(0, 10);
try {
localStorage.setItem(RECENTLY_VIEWED_KEY, JSON.stringify(recentlyViewed));
} catch (e) {
console.error('Failed to save recently viewed:', e);
}
}
function getRecentlyViewed() {
return recentlyViewed
.map(id => recipes.find(r => r.id === id))
.filter(Boolean);
}
window.toggleFavorite = toggleFavorite;
window.isFavorite = isFavorite;
function loadUrlState() {
const params = new URLSearchParams(window.location.search);
const q = params.get('q');
if (q) {
currentFilter.search = q.toLowerCase();
const searchInput = document.getElementById('search-input');
if (searchInput) searchInput.value = q;
}
const cat = params.get('cat');
if (cat) {
currentFilter.category = cat;
const categorySelect = document.getElementById('category-filter');
if (categorySelect) categorySelect.value = cat;
}
const ing = params.get('ing');
if (ing) {
selectedIngredients = ing.split(',').map(i => i.trim()).filter(Boolean);
renderSelectedIngredients();
}
const diet = params.get('diet');
if (diet && DIET_PRESETS[diet]) {
applyDietPreset(diet);
}
const time = params.get('time');
if (time) {
nutritionFilter.timeLimit = parseInt(time, 10);
const timeSelect = document.getElementById('time-filter');
if (timeSelect) timeSelect.value = time;
}
}
function updateUrlState() {
const params = new URLSearchParams();
if (currentFilter.search) params.set('q', currentFilter.search);
if (currentFilter.category) params.set('cat', currentFilter.category);
if (selectedIngredients.length > 0) params.set('ing', selectedIngredients.join(','));
if (nutritionFilter.activeDietPreset) params.set('diet', nutritionFilter.activeDietPreset);
if (nutritionFilter.timeLimit) params.set('time', nutritionFilter.timeLimit);
const newUrl = params.toString()
? `${window.location.pathname}?${params.toString()}`
: window.location.pathname;
window.history.replaceState({}, '', newUrl);
}
function handleRouting() {
const path = window.location.pathname;
const hash = window.location.hash;
if (path.includes('recipe.html') && hash) {
const recipeId = hash.slice(1);
renderRecipeDetail(recipeId);
} else if (path.includes('index.html') || path.endsWith('/')) {
renderHomePage();
}
}
function renderHomePage() {
renderCategoryFilter();
renderTagFilters();
renderRecipeGrid();
}
function renderCategoryFilter() {
const select = document.getElementById('category-filter');
if (!select) return;
const sortedCategories = Array.from(categories).sort();
let html = '<option value="">All Categories</option>';
sortedCategories.forEach(cat => {
html += `<option value="${escapeAttr(cat)}">${escapeHtml(capitalizeFirst(cat))}</option>`;
});
select.innerHTML = html;
}
function getTagsForSelectedCollections() {
const selectedCollections = currentFilter.collections || [];
const tags = new Set();
if (!ingredientIndex || !ingredientIndex.meta.collections) {
return Array.from(allTags).sort();
}
const collectionIdMap = {
'grandma-baker': 'grandma-baker',
'mommom': 'mommom-baker',
'granny': 'granny-hudson',
'all': 'all'
};
for (const uiId of selectedCollections) {
const indexId = collectionIdMap[uiId] || uiId;
const collectionInfo = ingredientIndex.meta.collections[indexId];
if (collectionInfo && collectionInfo.tags) {
collectionInfo.tags.forEach(tag => tags.add(tag));
}
}
if (tags.size === 0) {
return Array.from(allTags).sort();
}
return Array.from(tags).sort();
}
function renderTagFilters() {
const container = document.getElementById('tag-filters');
if (!container) return;
const sortedTags = getTagsForSelectedCollections();
const currentTag = currentFilter.tag;
if (currentTag && !sortedTags.includes(currentTag.toLowerCase())) {
currentFilter.tag = '';
}
let html = '';
if (sortedTags.length === 0) {
html = '<span class="no-tags">No tags available for selected collections</span>';
} else {
sortedTags.forEach(tag => {
const isActive = currentFilter.tag === tag ? ' active' : '';
html += `<span class="filter-tag${isActive}" data-tag="${escapeAttr(tag)}">${escapeHtml(tag)}</span>`;
});
}
container.innerHTML = html;
container.querySelectorAll('.filter-tag').forEach(el => {
el.addEventListener('click', () => {
const tag = el.dataset.tag;
if (currentFilter.tag === tag) {
currentFilter.tag = '';
el.classList.remove('active');
} else {
container.querySelectorAll('.filter-tag').forEach(t => t.classList.remove('active'));
currentFilter.tag = tag;
el.classList.add('active');
}
renderRecipeGrid();
});
});
}
function renderRecipeGrid() {
const container = document.getElementById('recipe-grid');
if (!container) return;
let filtered = recipes.filter(recipe => {
if (recipe.variant_of && recipe.variant_of !== recipe.id) {
return false;
}
if (currentFilter.search) {
if (pagefindSearchResults !== null && pagefindSearchResults.localIds) {
if (!pagefindSearchResults.localIds.includes(recipe.id)) return false;
} else {
const searchText = [
recipe.title,
recipe.description,
recipe.attribution,
...recipe.tags || []
].join(' ').toLowerCase();
if (!searchText.includes(currentFilter.search)) return false;
}
}
if (currentFilter.category && recipe.category !== currentFilter.category) {
return false;
}
if (currentFilter.tag && (!recipe.tags || !recipe.tags.includes(currentFilter.tag))) {
return false;
}
if (currentFilter.collections && currentFilter.collections.length > 0) {
const recipeCollection = recipe.collection || '';
if (!currentFilter.collections.includes(recipeCollection)) {
return false;
}
}
if (currentFilter.ingredientMatchInfo && currentFilter.ingredientMatchInfo.matches.length > 0) {
const matchInfo = currentFilter.ingredientMatchInfo.matches.find(m => m.recipeId === recipe.id);
if (!matchInfo) {
return false;
}
}
if (nutritionFilter.timeLimit) {
const recipeTime = parseTimeToMinutes(recipe.total_time || recipe.cook_time);
if (recipeTime === null || recipeTime > nutritionFilter.timeLimit) {
return false;
}
}
if (nutritionFilter.onlyWithNutrition && !recipe.nutrition) {
return false;
}
if (recipe.nutrition) {
const n = recipe.nutrition;
if (nutritionFilter.calories.min !== null && (n.calories === undefined || n.calories < nutritionFilter.calories.min)) {
return false;
}
if (nutritionFilter.calories.max !== null && n.calories !== undefined && n.calories > nutritionFilter.calories.max) {
return false;
}
if (nutritionFilter.carbs.min !== null && (n.carbohydrates === undefined || n.carbohydrates < nutritionFilter.carbs.min)) {
return false;
}
if (nutritionFilter.carbs.max !== null && n.carbohydrates !== undefined && n.carbohydrates > nutritionFilter.carbs.max) {
return false;
}
if (nutritionFilter.protein.min !== null && (n.protein === undefined || n.protein < nutritionFilter.protein.min)) {
return false;
}
if (nutritionFilter.protein.max !== null && n.protein !== undefined && n.protein > nutritionFilter.protein.max) {
return false;
}
if (nutritionFilter.fat.min !== null && (n.fat === undefined || n.fat < nutritionFilter.fat.min)) {
return false;
}
if (nutritionFilter.fat.max !== null && n.fat !== undefined && n.fat > nutritionFilter.fat.max) {
return false;
}
} else if (hasActiveNutritionFilter()) {
return false;
}
return true;
});
if (currentFilter.ingredientMatchInfo && currentFilter.ingredientMatchInfo.matches.length > 0) {
filtered.sort((a, b) => {
const matchA = currentFilter.ingredientMatchInfo.matches.find(m => m.recipeId === a.id);
const matchB = currentFilter.ingredientMatchInfo.matches.find(m => m.recipeId === b.id);
const countA = matchA ? matchA.matchCount : 0;
const countB = matchB ? matchB.matchCount : 0;
if (countB !== countA) return countB - countA;
return a.title.localeCompare(b.title);
});
} else {
filtered.sort((a, b) => a.title.localeCompare(b.title));
}
if (filtered.length === 0) {
container.innerHTML = `
<div class="text-center text-muted" style="grid-column: 1/-1; padding: 2rem;">
<p>No recipes found matching your criteria.</p>
<button class="btn btn-secondary" onclick="clearFilters()">Clear Filters</button>
</div>
`;
return;
}
let html = '';
filtered.forEach(recipe => {
const matchInfo = currentFilter.ingredientMatchInfo
? currentFilter.ingredientMatchInfo.matches.find(m => m.recipeId === recipe.id)
: null;
html += renderRecipeCard(recipe, matchInfo);
});
if (pagefindSearchResults && pagefindSearchResults.remoteResults && pagefindSearchResults.remoteResults.length > 0) {
html += `
<div class="remote-results-section" style="grid-column: 1/-1; margin-top: 2rem; padding-top: 1rem; border-top: 2px dashed var(--color-teal-light);">
<h3 style="color: var(--color-teal-dark); margin-bottom: 1rem;">Also found in other collections:</h3>
<div class="remote-results-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1rem;">
`;
pagefindSearchResults.remoteResults.forEach(result => {
html += `
<a href="${escapeAttr(result.url)}" class="remote-recipe-card" target="_blank" rel="noopener"
style="display: block; padding: 1rem; background: var(--color-cream); border: 1px solid var(--color-border); border-radius: 8px; text-decoration: none; color: inherit; transition: transform 0.2s, box-shadow 0.2s;">
<div style="font-size: 0.75rem; color: var(--color-coral); margin-bottom: 0.25rem;">${escapeHtml(result.collection)}</div>
<div style="font-weight: 600; color: var(--color-teal-dark);">${escapeHtml(result.title)}</div>
${result.category ? `<div style="font-size: 0.8rem; color: #666;">${escapeHtml(result.category)}</div>` : ''}
<div style="font-size: 0.7rem; color: var(--color-teal); margin-top: 0.5rem;">View on ${escapeHtml(result.collection)} ‚Üí</div>
</a>
`;
});
html += `</div></div>`;
}
container.innerHTML = html;
}
function renderRecipeCard(recipe, ingredientMatchInfo = null) {
const categoryIcon = getCategoryIcon(recipe.category);
const timeInfo = recipe.total_time || recipe.cook_time || '';
let matchBadgeHtml = '';
if (ingredientMatchInfo) {
if (ingredientMatchInfo.isPerfectMatch) {
matchBadgeHtml = '<span class="match-badge match-badge-perfect">Perfect Match</span>';
} else {
matchBadgeHtml = `<span class="match-badge match-badge-partial">${ingredientMatchInfo.matchCount}/${ingredientMatchInfo.totalSelected} matched</span>`;
}
}
let missingHtml = '';
if (ingredientMatchInfo && ingredientMatchInfo.missingIngredients.length > 0) {
missingHtml = `
<div class="recipe-missing-ingredients">
<strong>Need:</strong> ${ingredientMatchInfo.missingIngredients.map(i => escapeHtml(i)).join(', ')}
</div>
`;
}
let substitutionHtml = '';
if (ingredientMatchInfo && ingredientMatchInfo.substitutionMatches && ingredientMatchInfo.substitutionMatches.length > 0) {
const subItems = ingredientMatchInfo.substitutionMatches.map(sub => {
return `<span class="substitution-item" title="${escapeAttr(sub.substituteInfo.notes || '')}">` +
`${escapeHtml(sub.userHas)} ‚Üí ${escapeHtml(sub.recipeNeeds)}</span>`;
}).join(', ');
substitutionHtml = `
<div class="recipe-substitutions">
<strong>Subs:</strong> ${subItems}
</div>
`;
}
const isInMealPlan = selectedMealRecipes.some(r => r.id === recipe.id);
const mealPlanBtnClass = isInMealPlan ? 'meal-plan-btn in-plan' : 'meal-plan-btn';
const mealPlanBtnText = isInMealPlan ? '‚úì In Plan' : '+ Meal Plan';
const mealPlanAction = isInMealPlan
? `removeFromShoppingList('${escapeAttr(recipe.id)}')`
: `addToShoppingList('${escapeAttr(recipe.id)}')`;
return `
<article class="recipe-card category-${escapeAttr(recipe.category)}">
<div class="recipe-card-image">
${matchBadgeHtml ? `<div class="match-badge-container">${matchBadgeHtml}</div>` : ''}
${categoryIcon}
</div>
<div class="recipe-card-content">
<span class="category">${escapeHtml(recipe.category) || 'Uncategorized'}</span>
<h3><a href="recipe.html#${escapeAttr(recipe.id)}">${escapeHtml(recipe.title)}</a></h3>
<p class="description">${escapeHtml(recipe.description)}</p>
${missingHtml}
${substitutionHtml}
<div class="meta">
${recipe.servings_yield ? `<span>${escapeHtml(recipe.servings_yield)}</span>` : ''}
${timeInfo ? `<span>${escapeHtml(timeInfo)}</span>` : ''}
</div>
<button type="button" class="${mealPlanBtnClass}" onclick="${mealPlanAction}; event.stopPropagation();">
${mealPlanBtnText}
</button>
</div>
</article>
`;
}
function renderCurrentRecipe() {
if (currentRecipeId) {
renderRecipeDetail(currentRecipeId, true);
}
}
async function renderRecipeDetail(recipeId, skipLoading = false) {
const container = document.getElementById('recipe-content');
if (!container) return;
if (currentRecipeId !== recipeId) {
activeSubstitutions = {};
currentRecipeId = recipeId;
}
if (!skipLoading) {
container.innerHTML = `
<div class="text-center" style="padding: 2rem;">
<p>Loading recipe...</p>
</div>
`;
}
const recipe = await loadFullRecipe(recipeId);
await Promise.all([loadKitchenTips(), loadSubstitutions()]);
if (!recipe) {
container.innerHTML = `
<div class="text-center">
<h2>Recipe Not Found</h2>
<p>Sorry, we couldn't find that recipe.</p>
<a href="index.html" class="btn btn-primary">Back to Recipes</a>
</div>
`;
return;
}
const variants = findVariants(recipe);
document.title = `${recipe.title} - Grandma's Recipe Archive`;
let html = `
<article class="recipe-detail">
<header class="recipe-header">
<h1>${escapeHtml(recipe.title)}</h1>
${recipe.attribution ? `<p class="recipe-attribution">From: ${escapeHtml(recipe.attribution)}</p>` : ''}
${recipe.source_note ? `<p class="recipe-source">${escapeHtml(recipe.source_note)}</p>` : ''}
${recipe.description ? `<p>${escapeHtml(recipe.description)}</p>` : ''}
<div class="header-controls">
<div class="confidence-indicator confidence-${escapeAttr(recipe.confidence?.overall || 'high')}">
Confidence: ${escapeHtml(capitalizeFirst(recipe.confidence?.overall || 'high'))}
</div>
${variants.length > 0 ? renderVariantsDropdown(recipe, variants) : ''}
</div>
<div class="action-buttons" style="margin-top: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
<button id="print-btn" class="btn btn-secondary btn-print">Print Recipe</button>
${recipe.conversions?.has_conversions ? `
<button id="metric-toggle" class="btn btn-secondary">
${showMetric ? 'Show US Units' : 'Show Metric'}
</button>
` : ''}
</div>
</header>
${renderQuickFacts(recipe)}
${renderScalingControls(recipe)}
<section class="ingredients-section">
<h2>Ingredients ${showMetric && recipe.conversions?.has_conversions ? '<span class="unit-badge">Metric (approx.)</span>' : ''}${recipeScale !== 1 ? `<span class="scale-badge">${recipeScale}√ó</span>` : ''}</h2>
${renderIngredientsList(recipe)}
</section>
<section class="instructions-section">
<h2>Instructions</h2>
<ol class="instructions-list">
${recipe.instructions.map(inst => {
const isInferred = inst.text.includes('[INFERRED]');
const text = inst.text.replace('[INFERRED] ', '');
return `<li class="${isInferred ? 'inferred' : ''}">${escapeHtml(text)}</li>`;
}).join('')}
</ol>
</section>
${recipe.oven_directions ? renderOvenDirections(recipe.oven_directions) : ''}
${recipe.frosting ? renderFrosting(recipe.frosting) : ''}
${recipe.nutrition ? renderNutrition(recipe.nutrition, recipe.servings_yield) : ''}
${recipe.notes && recipe.notes.length > 0 ? renderNotes(recipe.notes) : ''}
${recipe.conversions?.conversion_assumptions?.length > 0 && showMetric ? renderConversionNotes(recipe.conversions) : ''}
${renderKitchenTipsForRecipe(recipe)}
${renderTags(recipe.tags)}
${renderConfidenceFlags(recipe.confidence?.flags)}
${renderOriginalScan(recipe.image_refs, recipe.collection)}
</article>
`;
container.innerHTML = html;
const printBtn = document.getElementById('print-btn');
if (printBtn) {
printBtn.addEventListener('click', () => window.print());
}
const metricToggle = document.getElementById('metric-toggle');
if (metricToggle) {
metricToggle.addEventListener('click', () => {
showMetric = !showMetric;
renderRecipeDetail(recipeId);
});
}
const variantSelect = document.getElementById('variant-select');
if (variantSelect) {
variantSelect.addEventListener('change', (e) => {
if (e.target.value) {
window.location.hash = e.target.value;
renderRecipeDetail(e.target.value);
}
});
}
document.querySelectorAll('.scale-btn').forEach(btn => {
btn.addEventListener('click', () => {
const scale = parseFloat(btn.dataset.scale);
if (!isNaN(scale)) {
setRecipeScale(scale, recipeId);
}
});
});
}
function findVariants(recipe) {
const variants = [];
const canonicalId = recipe.canonical_id || recipe.id;
recipes.forEach(r => {
if (r.id === recipe.id) return;
if (r.variant_of === recipe.id || r.variant_of === canonicalId) {
variants.push(r);
}
if (recipe.variant_of && (r.id === recipe.variant_of || r.variant_of === recipe.variant_of)) {
if (r.id !== recipe.id) variants.push(r);
}
if (r.canonical_id === canonicalId && r.id !== recipe.id) {
variants.push(r);
}
});
return variants;
}
function renderVariantsDropdown(currentRecipe, variants) {
return `
<div class="variants-dropdown">
<label for="variant-select">Variants:</label>
<select id="variant-select" class="variant-select">
<option value="${escapeAttr(currentRecipe.id)}" selected>${escapeHtml(currentRecipe.source_note || 'Current version')}</option>
${variants.map(v => `
<option value="${escapeAttr(v.id)}">${escapeHtml(v.source_note || v.title)}${v.variant_notes ? ` - ${escapeHtml(v.variant_notes.substring(0, 50))}...` : ''}</option>
`).join('')}
</select>
</div>
`;
}
function renderIngredientsList(recipe) {
const ingredients = showMetric && recipe.conversions?.ingredients_metric?.length > 0
? recipe.conversions.ingredients_metric
: recipe.ingredients;
return `
<ul class="ingredients-list">
${ingredients.map((ing, index) => {
const activeSub = activeSubstitutions[index];
const displayItem = activeSub ? activeSub.substitute.ingredient : ing.item;
const scaled = scaleQuantity(ing.quantity, recipeScale);
const warning = checkPracticalMinimum(scaled.value, ing.unit);
const subRule = findSubstitutionsForIngredient(ing.item);
const hasSubstitutes = subRule && subRule.substitutes && subRule.substitutes.length > 0;
const swapClasses = [
hasSubstitutes ? 'has-substitutes' : '',
activeSub ? 'is-swapped' : ''
].filter(Boolean).join(' ');
return `
<li class="${warning ? 'has-warning' : ''} ${swapClasses}">
<span class="ingredient-quantity ${recipeScale !== 1 ? 'scaled' : ''}">${escapeHtml(scaled.display)} ${escapeHtml(ing.unit || '')}</span>
<span class="ingredient-item ${hasSubstitutes ? 'swappable' : ''}"
${hasSubstitutes ? `onclick="showSubstitutionModal(${index}, ${escapeAttr(JSON.stringify(ing))}, ${escapeAttr(JSON.stringify(subRule))})"` : ''}>
${escapeHtml(displayItem)}
${ing.prep_note ? `<span class="ingredient-prep">, ${escapeHtml(ing.prep_note)}</span>` : ''}
${hasSubstitutes ? '<span class="swap-icon" title="Click to swap ingredient">‚áÑ</span>' : ''}
${activeSub ? '<span class="swapped-badge">swapped</span>' : ''}
</span>
${warning ? `<span class="ingredient-warning" title="${escapeAttr(warning)}">‚ö†Ô∏è</span>` : ''}
</li>
`;
}).join('')}
</ul>
${Object.keys(activeSubstitutions).length > 0 ? `
<button class="btn btn-link reset-subs-btn" onclick="resetSubstitutions()">
‚Ü© Reset all substitutions
</button>
` : ''}
`;
}
function renderNutrition(nutrition, servings) {
if (!nutrition || nutrition.status === 'insufficient_data') {
if (nutrition?.missing_inputs?.length > 0) {
return `
<section class="nutrition-section nutrition-incomplete">
<h3>Nutrition Information</h3>
<p class="text-muted">Nutrition data incomplete. Missing: ${escapeHtml(nutrition.missing_inputs.join(', '))}</p>
</section>
`;
}
return '';
}
const adjustedNutrition = Object.keys(activeSubstitutions).length > 0
? calculateAdjustedNutrition(nutrition)
: nutrition;
const n = adjustedNutrition.per_serving;
if (!n) return '';
const hasAdjustments = adjustedNutrition.substitutionNote;
return `
<section class="nutrition-section ${hasAdjustments ? 'nutrition-adjusted' : ''}">
<h3>Nutrition Information ${servings ? `<span class="text-muted">(per serving)</span>` : ''}
${hasAdjustments ? '<span class="adjusted-badge">adjusted</span>' : ''}
</h3>
<div class="nutrition-grid">
${n.calories !== null ? `<div class="nutrition-item ${hasAdjustments ? 'adjusted' : ''}"><span class="nutrition-value">${escapeHtml(n.calories)}</span><span class="nutrition-label">Calories</span></div>` : ''}
${n.fat_g !== null ? `<div class="nutrition-item ${hasAdjustments ? 'adjusted' : ''}"><span class="nutrition-value">${escapeHtml(n.fat_g)}g</span><span class="nutrition-label">Fat</span></div>` : ''}
${n.carbs_g !== null ? `<div class="nutrition-item ${hasAdjustments ? 'adjusted' : ''}"><span class="nutrition-value">${escapeHtml(n.carbs_g)}g</span><span class="nutrition-label">Carbs</span></div>` : ''}
${n.protein_g !== null ? `<div class="nutrition-item ${hasAdjustments ? 'adjusted' : ''}"><span class="nutrition-value">${escapeHtml(n.protein_g)}g</span><span class="nutrition-label">Protein</span></div>` : ''}
${n.sodium_mg !== null ? `<div class="nutrition-item"><span class="nutrition-value">${escapeHtml(n.sodium_mg)}mg</span><span class="nutrition-label">Sodium</span></div>` : ''}
${n.fiber_g !== null ? `<div class="nutrition-item"><span class="nutrition-value">${escapeHtml(n.fiber_g)}g</span><span class="nutrition-label">Fiber</span></div>` : ''}
${n.sugar_g !== null ? `<div class="nutrition-item"><span class="nutrition-value">${escapeHtml(n.sugar_g)}g</span><span class="nutrition-label">Sugar</span></div>` : ''}
</div>
${hasAdjustments ? `
<p class="nutrition-adjusted-note">
<small>${escapeHtml(adjustedNutrition.substitutionNote)} - estimates may vary</small>
</p>
` : ''}
${nutrition.assumptions?.length > 0 ? `
<p class="nutrition-assumptions text-muted">
<small>Assumptions: ${escapeHtml(nutrition.assumptions.join('; '))}</small>
</p>
` : ''}
</section>
`;
}
function renderConversionNotes(conversions) {
if (!conversions?.conversion_assumptions?.length) return '';
return `
<section class="notes-section conversion-notes" style="border-left-color: #6c757d;">
<h3>Conversion Notes</h3>
<p class="text-muted"><small>Metric conversions are approximate. Assumptions used:</small></p>
<ul>
${conversions.conversion_assumptions.map(a => `<li><small>${escapeHtml(a)}</small></li>`).join('')}
</ul>
</section>
`;
}
function renderQuickFacts(recipe) {
const facts = [];
if (recipe.servings_yield) facts.push({ label: 'Yield', value: recipe.servings_yield });
if (recipe.prep_time) facts.push({ label: 'Prep', value: recipe.prep_time });
if (recipe.cook_time) facts.push({ label: 'Cook', value: recipe.cook_time });
if (recipe.total_time) facts.push({ label: 'Total', value: recipe.total_time });
if (recipe.temperature) facts.push({ label: 'Temp', value: recipe.temperature });
if (facts.length === 0) return '';
return `
<div class="recipe-quick-facts">
${facts.map(f => `
<div class="quick-fact">
<span class="quick-fact-label">${escapeHtml(f.label)}</span>
<span class="quick-fact-value">${escapeHtml(f.value)}</span>
</div>
`).join('')}
</div>
`;
}
function renderOvenDirections(directions) {
return `
<section class="sub-recipe">
<h3>Oven Directions (Alternative)</h3>
<ol class="instructions-list">
${directions.map(d => `<li>${escapeHtml(d.text)}</li>`).join('')}
</ol>
</section>
`;
}
function renderFrosting(frosting) {
return `
<section class="sub-recipe">
<h3>${escapeHtml(frosting.name)}</h3>
<h4>Ingredients:</h4>
<ul class="ingredients-list">
${frosting.ingredients.map(ing => `
<li>
<span class="ingredient-quantity">${escapeHtml(ing.quantity)} ${escapeHtml(ing.unit)}</span>
<span class="ingredient-item">${escapeHtml(ing.item)}</span>
</li>
`).join('')}
</ul>
<h4>Instructions:</h4>
<p>${escapeHtml(frosting.instructions)}</p>
</section>
`;
}
function renderNotes(notes) {
return `
<section class="notes-section">
<h3>Notes</h3>
<ul>
${notes.map(note => `<li>${escapeHtml(note)}</li>`).join('')}
</ul>
</section>
`;
}
function renderTags(tags) {
if (!tags || tags.length === 0) return '';
return `
<div class="recipe-tags">
${tags.map(tag => `<span class="recipe-tag">${escapeHtml(tag)}</span>`).join('')}
</div>
`;
}
function renderConfidenceFlags(flags) {
if (!flags || flags.length === 0) return '';
return `
<section class="notes-section" style="border-left-color: #f0ad4e;">
<h3>Transcription Notes</h3>
<ul>
${flags.map(flag => `
<li>
<strong>${escapeHtml(flag.field)}:</strong> ${escapeHtml(flag.issue)}
${flag.candidates && flag.candidates.length > 0 ?
`<br><em>Possible values: ${escapeHtml(flag.candidates.join(', '))}</em>` : ''}
</li>
`).join('')}
</ul>
</section>
`;
}
function getCollectionImagePath(collection, isRemote = false, remoteSiteUrl = null) {
if (isRemote && remoteSiteUrl) {
return remoteSiteUrl + 'data/';
}
return 'data/';
}
function renderOriginalScan(imageRefs, collection) {
if (!imageRefs || imageRefs.length === 0) return '';
const basePath = getCollectionImagePath(collection);
return `
<section class="original-scan">
<h3>Original Scan</h3>
${imageRefs.map(ref => {
const safePath = sanitizeUrl(basePath + ref);
return `
<a href="${escapeAttr(safePath)}" target="_blank">
<img src="${escapeAttr(safePath)}" alt="Original recipe scan" class="scan-thumbnail"
style="max-width: 200px; max-height: 150px; object-fit: cover;">
</a>
`;}).join('')}
</section>
`;
}
function getCategoryIcon(category) {
const icons = {
appetizers: 'ü•ó',
beverages: 'üçπ',
breads: 'üçû',
breakfast: 'üç≥',
desserts: 'üç™',
mains: 'üçΩÔ∏è',
salads: 'ü•¨',
sides: 'ü•ï',
soups: 'üç≤',
snacks: 'üçø'
};
return icons[category] || 'üìñ';
}
function clearFilters() {
currentFilter = { search: '', category: '', tag: '', collections: ['grandma-baker', 'mommom', 'granny', 'all'], ingredients: [], ingredientMatchInfo: null };
pagefindSearchResults = null;
const searchInput = document.getElementById('search-input');
if (searchInput) searchInput.value = '';
const categorySelect = document.getElementById('category-filter');
if (categorySelect) categorySelect.value = '';
document.querySelectorAll('.filter-tag').forEach(el => el.classList.remove('active'));
const collectionFilters = document.getElementById('collection-filters');
if (collectionFilters) {
collectionFilters.querySelectorAll('input[type="checkbox"][data-collection]').forEach(checkbox => {
checkbox.checked = true;
});
const selectAllBtn = document.getElementById('collection-select-all');
if (selectAllBtn) {
selectAllBtn.textContent = 'Clear All';
}
}
saveCollectionPreferences();
selectedIngredients = [];
renderSelectedIngredients();
const ingredientInput = document.getElementById('ingredient-input');
if (ingredientInput) ingredientInput.value = '';
const resultsDiv = document.getElementById('ingredient-search-results');
if (resultsDiv) resultsDiv.classList.add('hidden');
const timeFilter = document.getElementById('time-filter');
if (timeFilter) timeFilter.value = '';
nutritionFilter.timeLimit = null;
clearNutritionFilters();
nutritionFilter.onlyWithNutrition = false;
updateNutritionInputs();
updateDietPresetButtons();
const onlyWithNutrition = document.getElementById('only-with-nutrition');
if (onlyWithNutrition) onlyWithNutrition.checked = false;
renderRecipeGrid();
}
window.clearFilters = clearFilters;
function capitalizeFirst(str) {
if (!str) return '';
return str.charAt(0).toUpperCase() + str.slice(1);
}
function debounce(func, wait) {
let timeout;
return function executedFunction(...args) {
const later = () => {
clearTimeout(timeout);
func(...args);
};
clearTimeout(timeout);
timeout = setTimeout(later, wait);
};
}
function showError(message) {
const container = document.getElementById('recipe-grid') || document.getElementById('recipe-content');
if (container) {
container.innerHTML = `
<div class="text-center" style="padding: 2rem; color: #721c24; background: #f8d7da; border-radius: 8px;">
<p>${escapeHtml(message)}</p>
</div>
`;
}
}